<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="pom-relationships">
  <title>The Project Object Model</title>

  <section id="pom-relationships-sect-intro">
    <title>Introduction</title>

    <para>This chapter covers the central concept of Maven—the Project
    Object<indexterm class="startofrange" id="pom1">
        <primary>POM (Project Object Model)</primary>
      </indexterm> Model. The <acronym>POM</acronym> is where a project’s
    identity and structure are declared, builds are configured, and projects
    are related to one another. The presence of a <filename
    moreinfo="none">pom.xml</filename> file defines a Maven project.</para>
  </section>

  <section id="pom-relationships-sect-pom">
    <title>The POM</title>

    <para>Maven projects, dependencies, builds, artifacts: all of these are
    objects to be modeled and described. These objects are described by an
    <acronym>XML</acronym> file called a Project Object Model. The
    <acronym>POM</acronym> tells Maven what sort of project it is dealing with
    and how to modify default behavior to generate output from source. In the
    same way a Java web application has a <filename
    moreinfo="none">web.xml</filename> that describes, configures, and
    customizes the application, a Maven project is defined by the presence
    of<indexterm>
        <primary>pom.xml file</primary>
      </indexterm><indexterm>
        <primary>pom.xml file</primary>

        <seealso>POM</seealso>
      </indexterm> a <filename moreinfo="none">pom.xml</filename>. It is a
    descriptive declaration of a project for Maven; it is the figurative “map”
    that Maven needs to understand what it is looking at when it builds your
    project.</para>

    <para>You could also think of the <filename
    moreinfo="none">pom.xml</filename> as analogous to a <filename
    moreinfo="none">Makefile</filename> or an Ant <filename
    moreinfo="none">build.xml</filename>. When you are using
    <acronym>GNU</acronym> <emphasis>make</emphasis> to build something like
    MySQL, you’ll usually have a file named <filename
    moreinfo="none">Makefile</filename> that contains explicit instructions
    for building a binary from source. When you are using Apache Ant, you
    likely have a file named <filename moreinfo="none">build.xml</filename>
    that contains explicit instructions for cleaning, compiling, packaging,
    and deploying an application. <emphasis>make</emphasis>, Ant, and Maven
    are similar in that they rely on the presence of a commonly named file
    such as <filename moreinfo="none">Makefile</filename>, <filename
    moreinfo="none">build.xml</filename>, or <filename
    moreinfo="none">pom.xml</filename>, but that is where the similarities
    end. If you look at a Maven <filename moreinfo="none">pom.xml</filename>,
    the majority of the <acronym>POM</acronym> is going to deal with
    descriptions: Where is the source code? Where are the resources? What is
    the packaging? If you look at an Ant <filename
    moreinfo="none">build.xml</filename> file, you’ll see something entirely
    different. You’ll see explicit instructions for tasks such as compiling a
    set of Java classes. The Maven <acronym>POM</acronym> is declarative, and
    although you can certainly choose to include some procedural
    customizations via the Maven Ant plugin, for the most part you will not
    need to get into the gritty procedural details of your project’s
    build.</para>

    <para>The <acronym>POM</acronym> is also not specific to building Java
    projects. While most of the examples in this book are geared towards Java
    applications, there is nothing Java-specific in the definition of a Maven
    Project Object Model. While Maven's default plugins are targeted at
    building <acronym>JAR</acronym> artifacts from a set of source, tests, and
    resources, there is nothing preventing you from defining a
    <acronym>POM</acronym> for a project that contains C# sources and produces
    some proprietary Microsoft binary using Microsoft tools. Similarly, there
    is nothing stopping you from defining a <acronym>POM</acronym> for a
    technical book. In fact, the source for this book and this book's examples
    is captured in a multi-module Maven project which uses one of the many
    Maven Docbook plugins to apply the standard Docbook <acronym>XSL</acronym>
    to a series of chapter <acronym>XML</acronym> files. Others have created
    Maven plugins to build Adobe Flex code into <acronym>SWC</acronym>s and
    <acronym>SWF</acronym>s, and yet others have used Maven to build projects
    written in C.</para>

    <para>We've established that the <acronym>POM</acronym> describes and
    declares, it is unlike Ant or Make in that it doesn't provide explicit
    instructions, and we've noted that <acronym>POM</acronym> concepts are not
    specific to Java. Diving into more specifics, take a look at <xref
    linkend="fig-pom" /> for a survey of the contents of a
    <acronym>POM</acronym>.</para>

    <para><figure id="fig-pom">
        <title>The Project Object Model</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figs/web/pom-relationships_pom-small.png" />
          </imageobject>
        </mediaobject>
      </figure></para>

    <para>The <acronym>POM</acronym> contains four categories of description
    and configuration:</para>

    <variablelist>
      <varlistentry>
        <term>General project information</term>

        <listitem>
          <para>This includes a project’s name, the <acronym>URL</acronym>
          for<indexterm>
              <primary>project information (in pom.xml)</primary>
            </indexterm><indexterm>
              <primary>licensing information (project information)</primary>
            </indexterm><indexterm>
              <primary>organizational information (project
              information)</primary>
            </indexterm><indexterm>
              <primary>developer information (project information)</primary>
            </indexterm><indexterm>
              <primary>pom.xml file</primary>

              <secondary>project information in</secondary>
            </indexterm> a project, the sponsoring organization, and a list of
          developers and contributors along with the license for a
          project.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Build settings</term>

        <listitem>
          <para>In this section, we customize the behavior of the
          default<indexterm>
              <primary>build information (in pom.xml)</primary>
            </indexterm><indexterm>
              <primary>pom.xml file</primary>

              <secondary>build information in</secondary>
            </indexterm> Maven build. We can change the location of source and
          tests, we can add new plugins, we can attach plugin goals to the
          lifecycle, and we can customize the site generation
          parameters.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>Build environment</term>

        <listitem>
          <para>The build environment consists of profiles that can
          be<indexterm>
              <primary>build environment</primary>
            </indexterm><indexterm>
              <primary>pom.xml file</primary>

              <secondary>build environment</secondary>
            </indexterm> activated for use in different environments. For
          example, during development you may want to deploy to a development
          server, whereas in production you want to deploy to a production
          server. The build environment customizes the build settings for
          specific environments and is often supplemented by a
          custom<indexterm>
              <primary>settings.xml file</primary>
            </indexterm> <filename moreinfo="none">settings.xml</filename> in
          <filename moreinfo="none">~/.m2</filename>. This settings file is
          discussed in <xref linkend="profiles" /> and in the section <xref
          linkend="appendix-settings-sect-details" />.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>POM relationships</term>

        <listitem>
          <para>A project rarely stands alone; it depends on other projects,
          inherits <acronym>POM</acronym> settings from parent projects,
          defines its own coordinates, and may include submodules.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <section id="pom-relationships-sect-super-pom">
      <title>The Super POM</title>

      <para>Before we dive into some examples of <acronym>POM</acronym>s,
      let's take a quick look at the Super <acronym>POM</acronym>. All Maven
      project <acronym>POM</acronym>s extend the Super <acronym>POM</acronym>
      which defines a set of defaults shared by all projects. This Super
      <acronym>POM</acronym> is a part of the Maven installation, and can be
      found in the <filename>maven-${maven.version}-uber.jar</filename> file
      in <filename>\${M2_HOME}/lib</filename>. If you look in this
      <acronym>JAR</acronym> file, you will find a file named
      <filename>pom-4.0.0.xml</filename> under the
      <package>org.apache.maven.project</package> package. The Super
      <acronym>POM</acronym> for Maven is shown in <xref
      linkend="ex-super-pom" />.</para>

      <example id="ex-super-pom">
        <title>The Super POM</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;name&gt;Maven Default Project&lt;/name&gt;

  &lt;repositories&gt;
    &lt;repository&gt;
      &lt;id&gt;central&lt;/id&gt; <co id="coDef-super-1"
            linkends="coRef-super-1" />
      &lt;name&gt;Maven Repository Switchboard&lt;/name&gt;
      &lt;layout&gt;default&lt;/layout&gt;
      &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt;
      &lt;snapshots&gt;
        &lt;enabled&gt;false&lt;/enabled&gt;
      &lt;/snapshots&gt;
    &lt;/repository&gt;
  &lt;/repositories&gt;

  &lt;pluginRepositories&gt;
    &lt;pluginRepository&gt;
      &lt;id&gt;central&lt;/id&gt; <co id="coDef-super-2"
            linkends="coRef-super-2" />
      &lt;name&gt;Maven Plugin Repository&lt;/name&gt;
      &lt;url&gt;http://repo1.maven.org/maven2&lt;/url&gt;
      &lt;layout&gt;default&lt;/layout&gt;
      &lt;snapshots&gt;
        &lt;enabled&gt;false&lt;/enabled&gt;
      &lt;/snapshots&gt;
      &lt;releases&gt;
        &lt;updatePolicy&gt;never&lt;/updatePolicy&gt;
      &lt;/releases&gt;
    &lt;/pluginRepository&gt;
  &lt;/pluginRepositories&gt;

  &lt;build&gt; <co id="coDef-super-3" linkends="coRef-super-3" />
    &lt;directory&gt;target&lt;/directory&gt;
    &lt;outputDirectory&gt;target/classes&lt;/outputDirectory&gt;
    &lt;finalName&gt;\${pom.artifactId}-\${pom.version}&lt;/finalName&gt;
    &lt;testOutputDirectory&gt;target/test-classes&lt;/testOutputDirectory&gt;
    &lt;sourceDirectory&gt;src/main/java&lt;/sourceDirectory&gt;
    &lt;scriptSourceDirectory&gt;src/main/scripts&lt;/scriptSourceDirectory&gt;
    &lt;testSourceDirectory&gt;src/test/java&lt;/testSourceDirectory&gt;
    &lt;resources&gt;
      &lt;resource&gt;
        &lt;directory&gt;src/main/resources&lt;/directory&gt;
      &lt;/resource&gt;
    &lt;/resources&gt;
    &lt;testResources&gt;
      &lt;testResource&gt;
        &lt;directory&gt;src/test/resources&lt;/directory&gt;
      &lt;/testResource&gt;
    &lt;/testResources&gt;
  &lt;/build&gt;

      &lt;pluginManagement&gt;<co id="coDef-super-4" linkends="coRef-super-4" />
       &lt;plugins&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;
           &lt;version&gt;1.1&lt;/version&gt;
         &lt;/plugin&gt;       
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2-beta-1&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.3&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-ear-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.3.1&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-ejb-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.1&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-javadoc-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.4&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-plugin-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.3&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-rar-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;                
           &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0-beta-7&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;                
           &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-site-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0-beta-6&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.0.4&lt;/version&gt;
         &lt;/plugin&gt;         
         &lt;plugin&gt;
            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
            &lt;version&gt;2.4.2&lt;/version&gt;
         &lt;/plugin&gt;
         &lt;plugin&gt;
           &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
           &lt;version&gt;2.1-alpha-1&lt;/version&gt;
         &lt;/plugin&gt;
       &lt;/plugins&gt;
     &lt;/pluginManagement&gt;
  
  &lt;reporting&gt;
    &lt;outputDirectory&gt;target/site&lt;/outputDirectory&gt;
  &lt;/reporting&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>The Super <acronym>POM</acronym> defines some standard
      configuration variables that are inherited by all projects. Those values
      are captured in the annotated sections:</para>

      <calloutlist>
        <callout arearefs="coDef-super-1" id="coRef-super-1">
          <para>The default Super <acronym>POM</acronym> defines a single
          remote Maven repository with an ID of <literal>central</literal>.
          This is the central Maven repository that all Maven clients are
          configured to read from by default. This setting can be overridden
          by a custom <filename moreinfo="none">settings.xml</filename> file.
          Note that the default Super <acronym>POM</acronym> has disabled
          snapshot artifacts on the central Maven repository. If you need to
          use a snapshot repository, you will need to customize repository
          settings in your <filename moreinfo="none">pom.xml</filename> or in
          your <filename moreinfo="none">settings.xml</filename>. Settings and
          profiles are covered in <xref linkend="profiles" /> and in <xref
          linkend="appendix-settings-sect-details" />.</para>
        </callout>

        <callout arearefs="coDef-super-2" id="coRef-super-2">
          <para>The central Maven repository also contains Maven plugins. The
          default plugin repository is the central Maven repository. Snapshots
          are disabled, and the update policy is set to “never,” which means
          that Maven will never automatically update a plugin if a new version
          is released.</para>
        </callout>

        <callout arearefs="coDef-super-3" id="coRef-super-3">
          <para>The <sgmltag>build</sgmltag> element sets the default values
          for directories in the Maven Standard Directory layout.</para>
        </callout>

        <callout arearefs="coDef-super-4" id="coRef-super-4">
          <para>Starting in Maven 2.0.9, default versions of core plugins have
          been provided in the Super <acronym>POM</acronym>. This was done to
          provide some stability for users that are not specifying versions in
          their <acronym>POM</acronym>s.</para>
        </callout>
      </calloutlist>

      <figure>
        <title>The Super POM is always the base Parent</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figs/web/pom-relationships_pom-inherit-simple-super.png" />
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section id="pom-relationships-sect-simplest-pom">
      <title>The Simplest POM</title>

      <para>All Maven <acronym>POM</acronym>s inherit defaults from the Super
      <acronym>POM</acronym> (introduced earlier in the section <xref
      linkend="pom-relationships-sect-super-pom" />”). If you are just writing
      a simple project that produces a <acronym>JAR</acronym> from some source
      in <filename moreinfo="none">src/main/java</filename>, want to run your
      JUnit tests in <filename moreinfo="none">src/test/java</filename>, and
      want to build a project site using <command moreinfo="none">mvn
      site</command>, you don’t have to customize anything. All you would
      need, in this case, is the simplest possible <acronym>POM</acronym>
      shown in <xref linkend="ex-simplest-pom" />. This <acronym>POM</acronym>
      defines a <varname>groupId</varname>, <varname>artifactId</varname>, and
      <varname>version</varname>: the three required coordinates for every
      project.</para>

      <example id="ex-simplest-pom">
        <title>The Simplest POM</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.ch08&lt;/groupId&gt;
  &lt;artifactId&gt;simplest-project&lt;/artifactId&gt;
  &lt;version&gt;1&lt;/version&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>Such a simple <acronym>POM</acronym> would be more than adequate
      for a simple project—e.g., a Java library that produces a
      <acronym>JAR</acronym> file. It isn’t related to any other projects, it
      has no dependencies, and it lacks basic information such as a name and a
      <acronym>URL</acronym>. If you were to create this file and then create
      the subdirectory <filename moreinfo="none">src/main/java</filename> with
      some source code, running <command moreinfo="none">mvn package</command>
      would produce a <acronym>JAR</acronym> in <filename
      moreinfo="none">target/simple-project-1.jar</filename>.</para>
    </section>

    <section id="pom-relationships-sect-effective-pom">
      <title>The Effective POM</title>

      <para>This simplest <acronym>POM</acronym> brings us to the concept of
      <indexterm>
          <primary>effective POMs</primary>
        </indexterm>the “effective <acronym>POM</acronym>.” Since
      <acronym>POM</acronym>s can inherit configuration from other
      <acronym>POM</acronym>s, you must always think of a Maven
      <acronym>POM</acronym> in terms of the combination of the Super
      <acronym>POM</acronym>, plus any parent <acronym>POM</acronym>s, and
      finally the current project’s <acronym>POM</acronym>. Maven starts with
      the Super <acronym>POM</acronym> and then overrides default
      configuration with one or more parent <acronym>POM</acronym>s. Then it
      overrides the resulting configuration with the current project’s
      <acronym>POM</acronym>. You end up with an effective
      <acronym>POM</acronym> that is a mixture of various
      <acronym>POM</acronym>s. If you want to see a project’s effective
      <acronym>POM</acronym>, you’ll need to run the
      <varname>effective-pom</varname> goal in the Maven Help plugin, which
      was introduced earlier in the section <xref
      linkend="installation-sect-help-plugin-install" />.” To run the
      <varname>effective-pom</varname> goal, execute the following in a
      directory with a <filename moreinfo="none">pom.xml</filename>
      file:</para>

      <screen>$ <command>mvn help:effective-pom</command></screen>

      <para>Executing the <varname>effective-pom</varname> goal should print
      out an <acronym>XML</acronym> document capturing the merge between the
      Super <acronym>POM</acronym> and the <acronym>POM</acronym> from <xref
      linkend="ex-simplest-pom" />.</para>
    </section>

    <section id="pom-relationships-sect-real-poms">
      <title>Real POMs</title>

      <para>Instead of typing up a contrived set of <acronym>POM</acronym>s to
      <indexterm>
          <primary>real POMs</primary>
        </indexterm>walk you through step-by-step, you should take a look at
      the examples in <xref linkend="part-example" />. Maven is something of a
      chameleon; you can pick and choose the features you want to take
      advantage of. Some open source projects may value the ability to list
      developers and contributors, generate clean project documentation, and
      manage releases automatically using the Maven Release plugin. On the
      other hand, someone working in a corporate environment on a small team
      might not be interested in the distribution management capabilities of
      Maven nor the ability to list developers. The remainder of this chapter
      is going to discuss features of the <acronym>POM</acronym> in isolation.
      Instead of bombarding you with a 10-page listing of a set of related
      <acronym>POM</acronym>s, we’re going to focus on creating a good
      reference for specific sections of the <acronym>POM</acronym>. In this
      chapter, we discuss relationships between <acronym>POM</acronym>s, but
      we don’t illustrate such a project here. If you are looking for such an
      illustration, refer to <xref linkend="multimodule-web-spring" />.</para>
    </section>
  </section>

  <section id="pom-relationships-sect-pom-syntax">
    <title>POM Syntax</title>

    <para>The <acronym>POM</acronym> is always <indexterm class="startofrange"
        id="pom2">
        <primary>POM (Project Object Model)</primary>

        <secondary>syntax</secondary>
      </indexterm>in a file named <filename moreinfo="none">pom.xml</filename>
    in the base directory of a Maven project. This <acronym>XML</acronym>
    document can start with the <acronym>XML</acronym> declaration, or you can
    choose to omit it. All values in a <acronym>POM</acronym> are captured as
    <acronym>XML</acronym> elements.</para>

    <section id="pom-reationships-sect-versions">
      <title>Project Versions</title>

      <para>A Maven project’s <sgmltag>version</sgmltag> encodes a
      release<indexterm>
          <primary>major versions (projects)</primary>
        </indexterm><indexterm>
          <primary>minor versions (projects)</primary>
        </indexterm><indexterm>
          <primary>incremental versions (projects)</primary>
        </indexterm><indexterm>
          <primary>qualifiers for project versions</primary>
        </indexterm><indexterm>
          <primary>project versions, about</primary>

          <seealso>version attribute</seealso>
        </indexterm><indexterm>
          <primary>version attribute (pom.xml)</primary>
        </indexterm><indexterm>
          <primary>project versions, about</primary>
        </indexterm> version number that is used to group and order releases.
      Maven versions contain the following parts: major version, minor
      version, incremental version, and qualifier. In a version, these parts
      correspond to the following format:</para>

      <screen>&lt;major version&gt;.&lt;minor version&gt;.&lt;incremental version&gt;-&lt;qualifier&gt;
</screen>

      <para>For example, the version "1.3.5" has a major version of 1, a minor
      version of 3, and an incremental version of 5. The version "5" has a
      major version of 5 and no minor or incremental version. The qualifier
      exists to capture milestone builds: alpha and beta releases, and the
      qualifier is separated from the major, minor, and incremental versions
      by a hyphen. For example, the version "1.3-beta-01" has a major version
      of 1, a minor version of 3, and a qualifier of "beta-01".</para>

      <para>Keeping your version numbers aligned with this standard will
      become very important when you want to start using version ranges in
      your <acronym>POM</acronym>s. Version ranges, introduced in <xref
      linkend="pom-relationships-sect-version-ranges" />, allow you to specify
      a dependency on a range of versions, and they are only supported because
      Maven has the ability to sort versions based on the version release
      number format introduced in this section.</para>

      <para>If your version release number matches the format
      <varname>&lt;major&gt;.&lt;minor&gt;.&lt;incremental&gt;-&lt;qualifier&gt;</varname>
      then your versions will be compared properly; "1.2.3" will be evaluated
      as a more recent build than "1.0.2", and the comparison will be made
      using the numeric values of the major, minor, and incremental versions.
      If your version release number does not fit the standard introduced in
      this section, then your versions will be compared as strings; "1.0.1b"
      will be compared to "1.2.0b" using a String comparison.</para>

      <section id="pom-relationships-sect-version-build-numbers">
        <title>Version Build Numbers</title>

        <para>One gotcha for release version numbers is the ordering of the
        <indexterm>
            <primary>ordering of version qualifiers</primary>
          </indexterm><indexterm>
            <primary>qualifiers for project versions</primary>

            <secondary>ordering of</secondary>
          </indexterm>qualifiers. Take the version release numbers
        “1.2.3-alpha-2” and “1.2.3-alpha-10,” where the “<phrase
        role="keep-together">alpha-2</phrase>” build corresponds to the 2nd
        alpha build, and the “alpha-10” build corresponds to the 10th alpha
        build. Even though “alpha-10” should be considered more recent than
        “alpha-2,” Maven is going to sort “alpha-10” before “alpha-2” due to a
        known issue in the way Maven handles version numbers.</para>

        <para>Maven is supposed to treat the number after the qualifier as a
        build number. In other words, the qualifier should be "alpha", and the
        build number should be 2. Even though Maven has been designed to
        separate the build number from the qualifier, this parsing is
        currently broken. As a result, "alpha-2" and "alpha-10" are compared
        using a String comparison, and "alpha-10" comes before "alpha-2"
        alphabetically. To get around this limitation, you will need to
        left-pad your qualified build numbers. If you use "alpha-02" and
        "alpha-10" this problem will go away, and it will continue to work
        once Maven properly parses the version build number.</para>
      </section>

      <section id="pom-relationships-sect-snapshot-versions">
        <title>SNAPSHOT Versions</title>

        <para>Maven versions can contain a string literal to signify that a
        <indexterm>
            <primary>snapshot versions</primary>
          </indexterm>project is currently under active development. If a
        version contains the string “SNAPSHOT,” then Maven will expand this
        token to a date and time value converted to <acronym>UTC</acronym>
        (Coordinated Universal Time) when you install or release this
        component. For example, if your project has a version of
        “1.0-SNAPSHOT” and you deploy this project’s artifacts to a Maven
        repository, Maven would expand this version to “1.0-20080207-230803-1”
        if you were to deploy a release at 11:08 PM on February 7th, 2008
        <acronym>UTC</acronym>. In other words, when you deploy a snapshot,
        you are not making a release of a software component; you are
        releasing a snapshot of a component at a specific time.</para>

        <para>Why would you use this? SNAPSHOT versions are used for projects
        under active development. If your project depends on a software
        component that is under active development, you can depend on a
        SNAPSHOT release, and Maven will periodically attempt to download the
        latest snapshot from a repository when you run a build. Similarly, if
        the next release of your system is going to have a version "1.4", your
        project would have a version "1.4-SNAPSHOT" version until it was
        formally released.</para>

        <para>As a default setting, Maven will not check for SNAPSHOT releases
        on remote repositories, to depend on SNAPSHOT releases, users must
        explicitly enable the ability to download snapshots using a
        <sgmltag>repository</sgmltag> or <sgmltag>pluginRepository</sgmltag>
        element in the <acronym>POM</acronym>.</para>

        <para>When releasing a project you should resolve all dependencies on
        SNAPSHOT versions to dependencies on released versions. If a project
        depends on a SNAPSHOT, it is not stable as the dependencies may change
        over time. Artifacts published to non-snapshot Maven repositories such
        as <ulink
        url="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</ulink>
        cannot depend on SNAPSHOT versions, as Maven's Super
        <acronym>POM</acronym> has snapshot's disabled from the Central
        repository. SNAPSHOT versions are for development only.</para>
      </section>

      <section id="pom-relationships-sect-latest-release">
        <title>LATEST and RELEASE Versions</title>

        <para>When you depend on a plugin or a dependency, you can use the a
        version value of LATEST or RELEASE. LATEST refers to the latest
        released or snapshot version of a particular artifact, the most
        recently deployed artifact in a particular repository. RELEASE refers
        to the last non-snapshot release in the repository. In general, it is
        not a best practice to design software which depends on a non-specific
        version of an artifact. If you are developing software, you might want
        to use RELEASE or LATEST as a convenience so that you don't have to
        update version numbers when a new release of a third-party library is
        released. When you release software, you should always make sure that
        your project depends on specific versions to reduce the chances of
        your build or your project being affected by a software release not
        under your control. Use LATEST and RELEASE with caution, if at
        all.</para>

        <para>Starting with Maven 2.0.9, Maven locks down the version numbers
        of common and core Maven plugins in the super POM to standardize a
        core set of Maven plugins for a particular version of Maven. This
        change was introduced to Maven 2.0.9 to bring stability and
        reproducibility to Maven builds. Before Maven 2.0.9, Maven would
        automatically update core Maven plugins using the LATEST version. This
        behavior led to a number of surprises when bugs was introduced into
        core plugins or functionality changed in a core plugin which
        subsequently broke a build. When Maven automatically updated core
        plugins, it was noted that there was little guarantee that a build
        would be reproducible as plugins could be updated whenever a new
        version was pushed to the central repository. Starting with Maven
        2.0.9, Maven, essentially, ships with a core set of locked down plugin
        versions. Non-core plugins, or plugins without versions assigned in
        the Super POM will still use the LATEST version to retrieve a plugin
        artifact from the repository. It is for this reason that you should
        assign explicit version numbers to any custom or non-core plugins used
        in your build.</para>
      </section>
    </section>

    <section id="pom-relationships-sect-property-refs">
      <title>Property References</title>

      <para>A <acronym>POM</acronym> can include references to properties
      <indexterm>
          <primary>properties</primary>

          <secondary>referencing in pom.xml</secondary>
        </indexterm><indexterm>
          <primary>references to properties, in pom.xml</primary>
        </indexterm>preceded by a dollar sign and surrounded by two curly
      braces. For example, consider the following
      <acronym>POM</acronym>:</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;build&gt;
    &lt;finalName&gt;\${project.groupId}-\${project.artifactId}&lt;/finalName&gt;
  &lt;/build&gt;
&lt;/project&gt;</programlisting>

      <para>If you put this <acronym>XML</acronym> in a
      <filename>pom.xml</filename> and run <command>mvn
      help:effective-pom</command>, you will see that the output contains the
      line:</para>

      <programlisting language="xml">...
&lt;finalName&gt;org.sonatype.mavenbook-project-a&lt;/finalName&gt;
...</programlisting>

      <para>When Maven reads a <acronym>POM</acronym>, it replaces references
      to properties when it loads the <acronym>POM</acronym>
      <acronym>XML</acronym>. Maven properties occur frequently in advanced
      Maven usage, and are similar to properties in other systems such as Ant
      or Velocity. They are simply variables delimited by
      <varname>\${...}</varname>. Maven provides three implicit variables
      which can be used to access environment variables,
      <acronym>POM</acronym> information, and Maven Settings:</para>

      <variablelist>
        <varlistentry>
          <term>env</term>

          <listitem>
            <para>The <varname>env</varname> variable exposes environment
            <indexterm>
                <primary>env variable</primary>
              </indexterm><indexterm>
                <primary>implicit variables, list of</primary>
              </indexterm>variables exposed by your operating system or shell.
            For example, a reference to <varname>\${env.PATH}</varname> in a
            Maven <acronym>POM</acronym> would be replaced by the
            <varname>\${PATH}</varname> environment variable (or
            <varname>%PATH%</varname> in Windows).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>project</term>

          <listitem>
            <para>The <varname>project</varname> variable exposes
            the<indexterm>
                <primary>project variable</primary>
              </indexterm> <acronym>POM</acronym>. You can use a dot-notated
            (.) path to reference the value of a <acronym>POM</acronym>
            element. For example, in this section we used the
            <varname>groupId</varname> and <varname>artifactId</varname> to
            set the <sgmltag>finalName</sgmltag> element in the build
            configuration. The syntax for this property reference was:
            <code>\${project.groupId}-\${project.</code><code>artifactId}</code>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>settings</term>

          <listitem>
            <para>The <varname>settings</varname> variable exposes Maven
            <indexterm>
                <primary>settings variable</primary>
              </indexterm>settings information. You can use a dot-notated (.)
            path to reference the value of an element in a <filename
            moreinfo="none">settings.xml</filename> file. For example,
            <varname>\${settings.offline}</varname> would reference the value
            of the <sgmltag>offline</sgmltag> element in <filename
            moreinfo="none">~/.m2/settings.xml</filename>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <note>
        <para>You may see older builds that use <varname>\${pom.xxx}</varname>
        or just <varname>\${xxx}</varname> to reference <acronym>POM</acronym>
        properties. These methods have been deprecated and only
        <varname>\${project.xxx}</varname> should be used.</para>
      </note>

      <para>In addition to the three implicit variables, you can reference
      <indexterm>
          <primary>system properties, referencing</primary>
        </indexterm>system properties and any custom properties set in the
      Maven <acronym>POM</acronym> or in a build profile:</para>

      <variablelist>
        <varlistentry>
          <term>Java System Properties</term>

          <listitem>
            <para>All properties accessible via<indexterm>
                <primary>Java system properties, referencing</primary>
              </indexterm> <methodname>getProperties()</methodname> on
            <classname>java.lang.System</classname> are exposed as
            <acronym>POM</acronym> properties. Some examples of system
            properties are: <varname>\${user.name}</varname>, <varname
            role="keep-together">\${user.home}</varname>,
            <varname>\${java.home}</varname>, and
            <varname>\${os.name}</varname>. A full list of system properties
            can be found in the Javadoc for the
            <classname>java.lang.System</classname> class.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>x</term>

          <listitem>
            <para>Arbitrary properties can be set with a<indexterm>
                <primary>arbitrary properties, referencing</primary>
              </indexterm> <varname>properties</varname> element in a
            <filename moreinfo="none">pom.xml</filename> or <filename
            moreinfo="none" role="keep-together">settings.xml</filename>, or
            properties can be loaded from external files. If you set a
            property named <varname>fooBar</varname> in your <filename
            moreinfo="none">pom.xml</filename>, that same property is
            referenced with <varname>\${fooBar}</varname>. Custom properties
            come in handy when you are building a system that filters
            resources and targets different deployment platforms. Here is the
            syntax for setting <literal>\${foo}=bar</literal> in a
            <acronym>POM</acronym>:</para>

            <programlisting language="xml">&lt;properties&gt;
  &lt;foo&gt;bar&lt;/foo&gt;
&lt;/properties&gt;</programlisting>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>For a more comprehensive list of available properties, see <xref
      linkend="resource-filtering" />.</para>
    </section>
  </section>

  <section id="pom-relationships-sect-project-dependencies">
    <title>Project Dependencies</title>

    <para>Maven can manage both internal and external dependencies.
    An<indexterm class="startofrange" id="pom3a">
        <primary>dependencies</primary>
      </indexterm><indexterm>
        <primary>POM (Project Object Model)</primary>

        <secondary>project dependencies</secondary>

        <see>dependencies</see>
      </indexterm><indexterm>
        <primary>project dependencies</primary>

        <see>dependencies</see>
      </indexterm><indexterm>
        <primary>external dependencies</primary>
      </indexterm><indexterm>
        <primary>internal dependencies</primary>

        <seealso>dependencies</seealso>
      </indexterm><indexterm>
        <primary>internal dependencies</primary>

        <seealso>dependencies</seealso>
      </indexterm> external dependency for a Java project might be a library
    such as Plexus, the Spring Framework, or Log4J. An internal dependency is
    illustrated by a web application project depending on another project that
    contains service classes, model objects, or persistence logic. <xref
    linkend="ex-dependency" /> shows some examples of project
    dependencies.</para>

    <para><example id="ex-dependency">
        <title>Project Dependencies</title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.codehaus.xfire&lt;/groupId&gt;
      &lt;artifactId&gt;xfire-java5&lt;/artifactId&gt;
      &lt;version&gt;1.2.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
      &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
      &lt;version&gt;2.4&lt;/version&gt;
      &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  ...
&lt;/project&gt;
</programlisting>
      </example></para>

    <para>The first dependency is a compile dependency on the XFire
    <acronym>SOAP</acronym> library from Codehaus. You would use this type of
    dependency if your project depended on this library for compilation,
    testing, and during execution. The second dependency is a
    <literal>test</literal>-scoped dependency on JUnit. You would use a
    <literal>test</literal>-scoped dependency when you need to reference this
    library only during testing. The last dependency in <xref
    linkend="ex-dependency" /> is a dependency on the Servlet 2.4
    <acronym>API</acronym>. The last dependency is scoped as a provided
    dependency. You would use a provided scope when the application you are
    developing needs a library for compilation and testing, but this library
    is supplied by a container at runtime.</para>

    <section id="pom-relationships-sect-dependency-scope">
      <title>Dependency Scope</title>

      <para><xref linkend="ex-dependency" /> briefly introduced three of the
      <indexterm>
          <primary>scope, dependency</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>scope of</secondary>
        </indexterm>five dependency scopes: <literal>compile</literal>,
      <literal>test</literal>, and <literal>provided</literal>. Scope controls
      which dependencies are available in which classpath, and which
      dependencies are included with an application. Let’s explore each scope
      in detail:</para>

      <variablelist>
        <varlistentry>
          <term>compile</term>

          <listitem>
            <para><literal>compile</literal> is the default scope; all
            dependencies are <indexterm>
                <primary>compile dependencies</primary>
              </indexterm><literal>compile</literal>-scoped if a scope is not
            supplied. <literal>compile</literal> dependencies are available in
            all classpaths, and they are packaged.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>provided</term>

          <listitem>
            <para><literal>provided</literal> dependencies are used when you
            expect the <acronym>JDK</acronym> or a container to provide them.
            For <indexterm>
                <primary>provided dependencies</primary>
              </indexterm>example, if you were developing a web application,
            you would need the Servlet <acronym>API</acronym> available on the
            compile classpath to compile a servlet, but you wouldn’t want to
            include the Servlet <acronym>API</acronym> in the packaged
            <acronym>WAR</acronym>; the Servlet <acronym>API</acronym>
            <acronym>JAR</acronym> is supplied by your application server or
            servlet container. <literal>provided</literal> dependencies are
            available on the compilation classpath (not runtime). They are not
            transitive, nor are they packaged.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>runtime</term>

          <listitem>
            <para><literal>runtime</literal> dependencies are required to
            execute and test the <indexterm>
                <primary>runtime dependencies</primary>
              </indexterm>system, but they are not required for compilation.
            For example, you may need a <acronym>JDBC</acronym>
            <acronym>API</acronym> <acronym>JAR</acronym> at compile time and
            the <acronym>JDBC</acronym> driver implementation only at
            runtime.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>test</term>

          <listitem>
            <para><literal>test</literal>-scoped dependencies are not required
            during the normal<indexterm>
                <primary>dependencies</primary>

                <secondary>test-scoped</secondary>
              </indexterm><indexterm>
                <primary>test-scoped dependencies</primary>
              </indexterm><indexterm>
                <primary>unit tests</primary>

                <secondary>test-scoped dependencies</secondary>
              </indexterm><indexterm>
                <primary>testing</primary>

                <secondary>using test-scoped dependencies</secondary>
              </indexterm> operation of an application, and they are available
            only during test compilation and execution phases. The
            <literal>test</literal> scope was previously introduced in <xref
            linkend="customizing-sect-test-scope" />.”</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>system</term>

          <listitem>
            <para>The <literal>system</literal> scope is similar to
            <literal>provided</literal> except that you have to <indexterm>
                <primary>system-scope dependencies</primary>
              </indexterm>provide an explicit path to the
            <acronym>JAR</acronym> on the local file system. This is intended
            to allow compilation against native objects that may be part of
            the system libraries. The artifact is assumed to always be
            available and is not looked up in a repository. If you declare the
            scope to be <literal>system</literal>, you must also provide the
            <sgmltag>systemPath</sgmltag> element. Note that this scope is not
            recommended (you should always try to reference dependencies in a
            public or custom Maven repository).</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section id="pom-relationships-sect-optional">
      <title>Optional Dependencies</title>

      <para>Assume that you are working on a library that provides caching
      <indexterm>
          <primary>optional dependencies</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>optional</secondary>
        </indexterm>behavior. Instead of writing a caching system from
      scratch, you want to use some of the existing libraries that provide
      caching on the file system and distributed caches. Also assume that you
      want to give the end user an option to cache on the file system or to
      use an in-memory distributed cache. To cache on the file system, you’ll
      want to use a freely available library called EHCache (<ulink
      url="http://ehcache.sourceforge.net/">http://ehcache.sourceforge.net/</ulink>),
      and to cache in a distributed <phrase
      role="keep-together">in-memory</phrase> cache, you want to use another
      freely available caching library named SwarmCache (<ulink
      url="http://swarmcache.sourceforge.net/">http://swarmcache.sourceforge.net/</ulink>).
      You’ll code an interface and create a library that can be configured to
      use either EHCache or SwarmCache, but you want to avoid adding a
      dependency on both caching libraries to any project that depends on your
      library.</para>

      <para>In other words, you need both libraries to compile this library
      project, but you don't want both libraries to show up as transitive
      runtime dependencies for the project that uses your library. You can
      accomplish this by using optional dependencies as shown in <xref
      linkend="ex-optional-depend" />.</para>

      <example id="ex-optional-depend">
        <title>Declaring Optional Dependencies</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;my-project&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
      &lt;artifactId&gt;ehcache&lt;/artifactId&gt;
      &lt;version&gt;1.4.1&lt;/version&gt;
      &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;swarmcache&lt;/groupId&gt;
      &lt;artifactId&gt;swarmcache&lt;/artifactId&gt;
      &lt;version&gt;1.0RC2&lt;/version&gt;
      &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;log4j&lt;/groupId&gt;
      &lt;artifactId&gt;log4j&lt;/artifactId&gt;
      &lt;version&gt;1.2.13&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>Once you've declared these dependencies as optional, you are
      required to include them explicitly in the project that depends on
      <varname>my-project</varname>. For example, if you were writing an
      application which depended on <varname>my-project</varname> and wanted
      to use the EHCache implementation, you would need to add the following
      <sgmltag>dependency</sgmltag> element to your project.</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;my-application&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
      &lt;artifactId&gt;my-project&lt;/artifactId&gt;
      &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt;
      &lt;artifactId&gt;swarmcache&lt;/artifactId&gt;
      &lt;version&gt;1.4.1&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>

      <para>In an ideal world, you wouldn’t have to use optional dependencies.
      Instead of having one large project with a series of optional
      dependencies, you would separate the <phrase
      role="keep-together">EHCache-specific</phrase> code to a
      <varname>my-project-ehcache</varname> submodule and the
      SwarmCache-specific code to a <varname>my-project-swarmcache</varname>
      submodule. This way, instead of requiring projects that reference
      <varname>my-project</varname> to specifically add a dependency, projects
      can just reference a particular implementation project and benefit from
      the transitive dependency.</para>
    </section>

    <section id="pom-relationships-sect-version-ranges">
      <title>Dependency Version Ranges</title>

      <para>You don’t just have to depend on a specific version of a<indexterm>
          <primary>version attribute (pom.xml)</primary>

          <secondary>dependency version ranges</secondary>
        </indexterm><indexterm>
          <primary>project versions, about</primary>

          <secondary>dependency version ranges</secondary>
        </indexterm><indexterm>
          <primary>ranges for dependency versions</primary>
        </indexterm> dependency; you can specify a range of versions that
      would satisfy a given dependency. For example, you can specify that your
      project depends on version 3.8 or greater of JUnit, or anything between
      versions 1.2.10 and 1.2.14 of JUnit. You do this by surrounding one or
      more version numbers with the following characters:</para>

      <variablelist>
        <varlistentry>
          <term role="plain">(, )</term>

          <listitem>
            <para>Exclusive quantifiers</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term role="plain">[, ]</term>

          <listitem>
            <para>Inclusive quantifiers</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>For example, if you wished to access any <code>JUnit</code>
      version greater than or equal to 3.8 but less than 4.0, your dependency
      would be as shown in <xref linkend="ex-dep-range" />.</para>

      <para><example id="ex-dep-range">
          <title>Specifying a Dependency Range: JUnit 3.8 - JUnit 4.0</title>

          <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;junit&lt;/groupId&gt;
  &lt;artifactId&gt;junit&lt;/artifactId&gt;
  &lt;version&gt;[3.8,4.0)&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</programlisting>
        </example></para>

      <para>If you want to depend on any version of JUnit no higher
      than<indexterm>
          <primary>upper boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>inclusive boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>lower boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>exclusive boundaries (version ranges)</primary>
        </indexterm><indexterm>
          <primary>boundaries for version ranges, specifying</primary>
        </indexterm> 3.8.1, you would specify only an upper inclusive
      boundary, as shown in <xref linkend="ex-dep-range-2" />.</para>

      <example id="ex-dep-range-2">
        <title>Specifying a Dependency Range: JUnit &lt;= 3.8.1</title>

        <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;junit&lt;/groupId&gt;
  &lt;artifactId&gt;junit&lt;/artifactId&gt;
  &lt;version&gt;[,3.8.1]&lt;/version&gt;ex-de
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</programlisting>
      </example>

      <para>A version before or after the comma is not required, and means +/-
      infinity. For example, "[4.0,)" means any version greater than or equal
      to 4.0. "(,2.0)" is any version less than 2.0. "[1.2]" means only
      version 1.2, and nothing else.</para>

      <note>
        <para>When declaring a "normal" version such as 3.8.2 for Junit,
        internally this is represented as "allow anything, but prefer 3.8.2."
        This means that when a conflict is detected, Maven is allowed to use
        the conflict algorithms to choose the best version. If you specify
        [3.8.2], it means that only 3.8.2 will be used and nothing else. If
        somewhere else there is a dependency that specifies [3.8.1], you would
        get a build failure telling you of the conflict. We point this out to
        make you aware of the option, but use it sparingly and only when
        really needed. The preferred way to resolve this is via
        <sgmltag>dependencyManagement</sgmltag>.</para>
      </note>
    </section>

    <section id="pom-relationships-sect-transitive">
      <title>Transitive Dependencies</title>

      <para>A transitive dependency is a dependency of a dependency.
      If<indexterm>
          <primary>transitive dependencies</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>transitive</secondary>

          <see>transitive dependencies</see>
        </indexterm> <varname>project-a</varname> depends on
      <varname>project-b</varname>, which in turn depends on
      <varname>project-c</varname>, then <varname>project-c</varname> is
      considered a transitive dependency of <varname>project-a</varname>. If
      <varname>project-c</varname> depended on <varname>project-d</varname>,
      then <varname>project-d</varname> would also be considered a transitive
      dependency of <varname>project-a</varname>. Part of Maven’s appeal is
      that it can manage transitive dependencies and shield the developer from
      having to keep track of all of the dependencies required to compile and
      run an application. You can just depend on something like the Spring
      Framework and not have to worry about tracking down every last
      dependency of the Spring Framework.</para>

      <para>Maven accomplishes this by building a graph of dependencies and
      dealing with any conflicts and overlaps that might occur. For example,
      if Maven sees that two projects depend on the same
      <varname>groupId</varname> and <varname>artifactId</varname>, it will
      sort out which dependency to use automatically, always favoring the more
      recent version of a dependency. Although this sounds convenient, there
      are some edge cases where transitive dependencies can cause some
      configuration issues. For these scenarios, you can use a dependency
      exclusion.</para>

      <section id="pom-relationships-sect-transitive-scope">
        <title>Transitive Dependencies and Scope</title>

        <para>Each of the scopes outlined earlier in the section <xref
        linkend="pom-relationships-sect-dependency-scope" />” affects not just
        the scope of <indexterm>
            <primary>scope, dependency</primary>

            <secondary>transitive dependencies and</secondary>
          </indexterm>the dependency in the declaring project, but also how it
        acts as a transitive dependency. The easiest way to convey this
        information is through a table, as in <xref
        linkend="table-transitive-dep-and-scope" />. Scopes in the top row
        represent the scope of a transitive dependency. Scopes in the leftmost
        column represent the scope of a direct dependency. The intersection of
        the row and column is the scope that is assigned to a transitive
        dependency. A blank cell in this table means that the transitive
        dependency will be omitted.</para>

        <para><table id="table-transitive-dep-and-scope">
            <title>How Scope Affects Transitive Dependencies</title>

            <tgroup cols="5">
              <thead>
                <row>
                  <entry>Direct Scope</entry>

                  <entry>Transitive Scope</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry></entry>

                  <entry><emphasis>compile</emphasis></entry>

                  <entry><emphasis>provided</emphasis></entry>

                  <entry><emphasis>runtime</emphasis></entry>

                  <entry><emphasis>test</emphasis></entry>
                </row>

                <row>
                  <entry><emphasis>compile</emphasis></entry>

                  <entry>compile</entry>

                  <entry>-</entry>

                  <entry>runtime</entry>

                  <entry>-</entry>
                </row>

                <row>
                  <entry><emphasis>provided</emphasis></entry>

                  <entry>provided</entry>

                  <entry>provided</entry>

                  <entry>provided</entry>

                  <entry>-</entry>
                </row>

                <row>
                  <entry><emphasis>runtime</emphasis></entry>

                  <entry>runtime</entry>

                  <entry>-</entry>

                  <entry>runtime</entry>

                  <entry>-</entry>
                </row>

                <row>
                  <entry><emphasis>test</emphasis></entry>

                  <entry>test</entry>

                  <entry>-</entry>

                  <entry>test</entry>

                  <entry>-</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>

        <para>To illustrate the relationship of transitive dependency scope to
        direct dependency scope, consider the following example. If
        <varname>project-a</varname> contains a test scoped dependency on
        <varname>project-b</varname> which contains a compile scoped
        dependency on <varname>project-c</varname>.
        <varname>project-c</varname> would be a test-scoped transitive
        dependency of <varname>project-a</varname>.</para>

        <para>You can think of this as a transitive boundary which acts as a
        filter on dependency scope. Transitive dependencies which are provided
        and test scope usually do not affect a project. The exception to this
        rule is that a provided scoped transitive dependency to a provided
        scope direct dependency is still a provided dependency of a project.
        Transitive dependencies which are compile and runtime scoped usually
        affect a project regardless of the scope of a direct dependency.
        Transitive dependencies which are compile scoped will have the same
        scope regardless of the scope of the direct dependency. Transitive
        dependencies which are runtime scoped will generally have the same
        scope of the direct dependency except when the direct dependency has a
        scope of compile. When a transitive dependency is runtime scoped and a
        direct is compile scoped the direct dependency the transitive
        dependency will have an effective scope of runtime.</para>
      </section>
    </section>

    <section id="pom-relationships-sect-conflict">
      <title>Conflict Resolution</title>

      <para>There will be times when you need to exclude a
      transitive<indexterm>
          <primary>conflict, dependency</primary>
        </indexterm><indexterm>
          <primary>resolving dependency conflicts</primary>
        </indexterm><indexterm>
          <primary>dependencies</primary>

          <secondary>conflicts with, resolving</secondary>
        </indexterm><indexterm>
          <primary>transitive dependencies</primary>

          <secondary>resolving conflicts with</secondary>
        </indexterm><indexterm>
          <primary>excluding transitive dependencies</primary>
        </indexterm><indexterm>
          <primary>replacing transitive dependencies</primary>
        </indexterm> dependency, such as when you are depending on a project
      that depends on another project, but you would like to either exclude
      the dependency altogether or replace the transitive dependency with
      another dependency that provides the same functionality. <xref
      linkend="ex-exclude" /> shows an example of a dependency element that
      adds a dependency on <varname>project-a</varname>, but excludes the
      transitive dependency <varname>project-b</varname>.</para>

      <para><example id="ex-exclude">
          <title>Excluding a Transitive Dependency</title>

          <programlisting language="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;exclusions&gt;
    &lt;exclusion&gt;
      &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
      &lt;artifactId&gt;project-b&lt;/artifactId&gt;
    &lt;/exclusion&gt;
  &lt;/exclusions&gt;
&lt;/dependency&gt;</programlisting>
        </example></para>

      <para>Often, you will want to replace a transitive dependency with
      another implementation. For example, if you are depending on a library
      that depends on the Sun <acronym>JTA</acronym> <acronym>API</acronym>,
      you may want to replace the declared transitive dependency. Hibernate is
      one example. Hibernate depends on the Sun <acronym>JTA</acronym>
      <acronym>API</acronym> <acronym>JAR</acronym>, which is not available in
      the central Maven repository because it cannot be freely redistributed.
      Fortunately, the Apache Geronimo project has created an independent
      implementation of this library that can be freely redistributed. To
      replace a transitive dependency with another dependency, you would
      exclude the transitive dependency and declare a dependency on the
      project you wanted instead. <xref linkend="ex-exclude-replace" /> shows
      an example of a such replacement.</para>

      <example id="ex-exclude-replace">
        <title>Excluding and Replacing a Transitive Dependency</title>

        <programlisting language="xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate&lt;/artifactId&gt;
    &lt;version&gt;3.2.5.ga&lt;/version&gt;
    &lt;exclusions&gt;
      &lt;exclusion&gt;
        &lt;groupId&gt;javax.transaction&lt;/groupId&gt;
        &lt;artifactId&gt;jta&lt;/artifactId&gt;
      &lt;/exclusion&gt;
    &lt;/exclusions&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.apache.geronimo.specs&lt;/groupId&gt;
    &lt;artifactId&gt;geronimo-jta_1.1_spec&lt;/artifactId&gt;
    &lt;version&gt;1.1&lt;/version&gt;
  &lt;/dependency&gt;
&lt;/dependencies&gt;</programlisting>
      </example>

      <para>In <xref linkend="ex-exclude-replace" />, there is nothing marking
      the dependency on <varname>geronimo-jta_1.1_spec</varname> as a
      replacement, it just happens to be a library which provides the same
      <acronym>API</acronym> as the original <acronym>JTA</acronym>
      dependency. Here are some other reasons you might want to exclude or
      replace transitive dependencies:</para>

      <orderedlist>
        <listitem>
          <para>The <varname>groupId</varname> or
          <varname>artifactId</varname> of the artifact has changed, where the
          current project requires an alternately named version from a
          dependency's version - resulting in 2 copies of the same project in
          the classpath. Normally Maven would capture this conflict and use a
          single version of the project, but when <varname>groupId</varname>
          or <varname>artifactId</varname> are different, Maven will consider
          this to be two different libraries.</para>
        </listitem>

        <listitem>
          <para>An artifact is not used in your project and the transitive
          dependency has not been marked as an optional dependency. In this
          case, you might want to exclude a dependency because it isn't
          something your system needs and you are trying to cut down on the
          number of libraries distributed with an application.</para>
        </listitem>

        <listitem>
          <para>An artifact which is provided by your runtime container thus
          should not be included with your build. An example of this is if a
          dependency depends on something like the Servlet API and you want to
          make sure that the dependency is not included in a web application's
          <filename>WEB-INF/lib</filename> directory.</para>
        </listitem>

        <listitem>
          <para>To exclude a dependency which might be an
          <acronym>API</acronym> with multiple implementations. This is the
          situation illustrated by <xref linkend="ex-exclude-replace" />;
          there is a Sun <acronym>API</acronym> which requires click-wrap
          licensing and a time-consuming manual install into a custom
          repository (Sun's <acronym>JTA</acronym> <acronym>JAR</acronym>)
          versus a freely distributed version of the same
          <acronym>API</acronym> available in the central Maven repository
          (Geronimo's <acronym>JTA</acronym> implementation).</para>
        </listitem>
      </orderedlist>
    </section>

    <section id="pom-relationships-sect-dep-manage">
      <title>Dependency Management</title>

      <para>Once you've adopted Maven at your super complex enterprise and you
      have two hundred and twenty inter-related Maven projects, you are going
      to start wondering if there is a better way to get a handle on
      dependency versions. If every single project that uses a dependency like
      the MySQL Java connector needs to independently list the version number
      of the dependency, you are going to run into problems when you need to
      upgrade to a new version. Because the version numbers are distributed
      throughout your project tree, you are going to have to manually edit
      each of the <filename>pom.xml</filename> files that reference a
      dependency to make sure that you are changing the version number
      everywhere. Even with <command>find</command>, <command>xargs</command>,
      and <command>awk</command>, you are still running the risk of missing a
      single <acronym>POM</acronym>.</para>

      <para>Luckily, Maven provides a way for you to consolidate dependency
      version numbers in the <sgmltag>dependencyManagement</sgmltag> element.
      You'll usually see the <sgmltag>dependencyManagement</sgmltag> element
      in a top-level parent <acronym>POM</acronym> for an organization or
      project. Using the <sgmltag>dependencyManagement</sgmltag> element in a
      <filename>pom.xml</filename> allows you to reference a dependency in a
      child project without having to explicitly list the version. Maven will
      walk up the parent-child hierarchy until it finds a project with a
      <sgmltag>dependencyManagement</sgmltag> element, it will then use the
      version specified in this <sgmltag>dependencyManagement</sgmltag>
      element.</para>

      <para>For example, if you have a large set of projects which make use of
      the MySQL Java connector version 5.1.2, you could define the following
      <sgmltag>dependencyManagement</sgmltag> element in your multi-module
      project's top-level <acronym>POM</acronym>.</para>

      <para><example>
          <title>Defining Dependency Versions in a Top-level POM</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
  &lt;version&gt;1.0.0&lt;/version&gt;
  ...
  &lt;dependencyManagement&gt;
    &lt;dependencies&gt;
      &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.2&lt;/version&gt;
      &lt;/dependency&gt;
      ...
    &lt;dependencies&gt;
  &lt;/dependencyManagement&gt;
</programlisting>

          <para>Then, in a child project, you can add a dependency to the
          MySQL Java Connector using the following dependency
          <acronym>XML</acronym>:</para>

          <programlisting language="xml">&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
    &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  ...
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>

          <para>You should notice that the child project did not have to
          explicitly list the version of the
          <varname>mysql-connector-java</varname> dependency. Because this
          dependency was defined in the top-level <acronym>POM</acronym>'s
          <sgmltag>dependencyManagement</sgmltag> element, the version number
          is going to propagate to the child project's dependency on
          <varname>mysql-connector-java</varname>. Note that if this child
          project did define a version, it would override the version listed
          in the top-level <acronym>POM</acronym>'s
          <sgmltag>dependencyManagement</sgmltag> section. That is, the
          <sgmltag>dependencyManagement</sgmltag> version is only used when
          the child does not declare a version directly.</para>

          <para>Dependency management in a top-level <acronym>POM</acronym> is
          different from just defining a dependency on a widely shared parent
          <acronym>POM</acronym>. For starters, all dependencies are
          inherited. If <varname>mysql-connector-java</varname> were listed as
          a dependency of the top-level parent project, every single project
          in the hierarchy would have a reference to this dependency. Instead
          of adding in unnecessary dependencies, using
          <sgmltag>dependencyManagement</sgmltag> allows you to consolidate
          and centralize the management of dependency versions without adding
          dependencies which are inherited by all children. In other words,
          the <sgmltag>dependencyManagement</sgmltag> element is equivalent to
          an environment variable which allows you to declare a dependency
          anywhere below a project without specifying a version number.</para>
        </example></para>
    </section>
  </section>

  <section id="pom-relationships-sect-project-relationships">
    <title>Project Relationships</title>

    <para>One of the compelling reasons to use Maven is that it makes the
    process of tracking down dependencies (and dependencies of dependencies)
    very easy. When a project depends on an artifact produced by another
    project we say that this artifact is a dependency. In the case of a Java
    project, this can be as simple as a project depending on an external
    dependency like Log4J or JUnit. While dependencies can model external
    dependencies, they can also manage the dependencies between a set of
    related projects, if <varname>project-a</varname> depends on
    <varname>project-b</varname>, Maven is smart enough to know that
    <varname>project-b</varname> must be built before
    <varname>project-a</varname>.</para>

    <para>Relationships are not only about dependencies and figuring out what
    one project needs to be able to build an artifact. Maven can model the
    relationship of a project to a parent, and the relationship of a project
    to submodules. This section gives an overview of the various relationships
    between projects and how such relationships are configured.</para>

    <section id="pom-relationships-sect-more-coordinates">
      <title>More on Coordinates</title>

      <para>Coordinates define a unique location for a project, they were
      first introduced in <xref linkend="simple-project" />. Projects are
      related to one another using Maven Coordinates. project-a doesn't just
      depend on project-b; a project with a groupId, artifactId, and version
      depends on another project with a groupId, artifactId, and version. To
      review, a Maven Coordinate is made up of three components:</para>

      <variablelist>
        <varlistentry>
          <term>groupId</term>

          <listitem>
            <para>A <varname>groupId</varname> groups a set of related
            artifacts. Group identifiers generally resemble a Java package
            name. For example, the <varname>groupId</varname>
            <varname>org.apache.maven</varname> is the base groupId for all
            artifacts produced by the Apache Maven project. Group identifiers
            are translated into paths in the Maven Repository; for example,
            the org.apache.maven groupId can be found in
            <filename>/maven2/org/apache/maven</filename> on <ulink
            url="http://repo1.maven.org/maven2/org/apache/maven">repo1.maven.org</ulink>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>artifactId</term>

          <listitem>
            <para>The <varname>artifactId</varname> is the project's main
            identifier. When you generate an artifact, this artifact is going
            to be named with the <varname>artifactId</varname>. When you refer
            to a project, you are going to refer to it using the
            <varname>artifactId</varname>. The <varname>artifactId</varname>,
            <varname>groupId</varname> combination must be unique. In other
            words, you can't have two separate projects with the same
            <varname>artifactId</varname> and <varname>groupId</varname>;
            <varname>artifactId</varname>s are unique within a particular
            <varname>groupId</varname>.</para>

            <note>
              <para>While '.'s are commonly used in
              <varname>groupId</varname>s, you should try to avoid using them
              in <varname>artifactId</varname>s. This can cause issues when
              trying to parse a fully qualified name down into the
              subcomponents.</para>
            </note>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>version</term>

          <listitem>
            <para>When an artifact is released, it is released with a version
            number. This version number is a numeric identifier such as "1.0",
            "1.1.1", or "1.1.2-alpha-01". You can also use what is known as a
            snapshot version. A snapshot version is a version for a component
            which is under development, snapshot version numbers always end in
            SNAPSHOT; for example, "1.0-SNAPSHOT", "1.1.1-SNAPSHOT", and
            "1-SNAPSHOT". <xref
            linkend="pom-relationships-sect-version-build-numbers" />
            introduces versions and version ranges.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>There is a fourth, less-used qualifier:</para>

      <variablelist>
        <varlistentry>
          <term>classifier</term>

          <listitem>
            <para>You would use a classifier if you were releasing the same
            code but needed to produce two separate artifacts for technical
            reasons. For example, if you wanted to build two separate
            artifacts of a <acronym>JAR</acronym>, one compiled with the Java
            1.4 compiler and another compiled with the Java 6 compiler, you
            might use the classifier to produce two separate
            <acronym>JAR</acronym> artifacts under the same
            groupId:artifactId:version combination. If your project uses
            native extensions, you might use the classifier to produce an
            artifact for each target platform. Classifiers are commonly used
            to package up an artifact's sources, JavaDocs or binary
            assemblies.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>When we talk of dependencies in this book, we often use the
      following shorthand notation to describe a dependency:
      <varname>groupId</varname>:<varname>artifactId</varname>:<varname>version</varname>.
      To refer to the 2.5 release of the Spring Framework, we would refer to
      it as <varname>org.springframework:spring:2.5</varname>. When you ask
      Maven to print out a list of dependencies with the Maven Dependency
      plugin, you will also see that Maven tends to print out log messages
      with this shorthand dependency notation.</para>
    </section>

    <section id="pom-relationships-sect-multi-module">
      <title>Multi-module Projects</title>

      <para>Multi-module projects are projects which contain a list of modules
      to build. A multi-module project always has a packaging of pom, and
      rarely produces an artifact. A multi-module project exists only to group
      projects together in a build. <xref linkend="fig-multiproject" /> shows
      a project hierarchy which includes two parent projects with packaging of
      <varname>pom</varname>, and three projects with packaging of
      <varname>jar</varname>.</para>

      <para><figure id="fig-multiproject">
          <title>Multi-module Project Relationships</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/web/pom_multimodule.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>The directory structure on the file system would also mirror the
      module relationships. A set of projects illustrated by <xref
      linkend="fig-multiproject" /> would have the following directory
      structure:</para>

      <programlisting>top-group/pom.xml
top-group/sub-group/pom.xml
top-group/sub-group/project-a/pom.xml
top-group/sub-group/project-b/pom.xml
top-group/project-c/pom.xml</programlisting>

      <para>The projects are related to one another because
      <varname>top-group</varname> and <varname>sub-group</varname> are
      referencing <varname>sub-modules</varname> in a <acronym>POM</acronym>.
      For example, the <varname>org.sonatype.mavenbook:top-group</varname>
      project is a multi-module project with packaging of type
      <varname>pom</varname>. <varname>top-group</varname>'s
      <filename>pom.xml</filename> would include the following modules
      element:</para>

      <example>
        <title>top-group modules element</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;top-group&lt;/artifactId&gt;
  ...
  &lt;modules&gt;
    &lt;module&gt;sub-group&lt;/module&gt;
    &lt;module&gt;project-c&lt;/module&gt;
  &lt;/modules&gt;
  ...
&lt;/project&gt;</programlisting>
      </example>

      <para>When Maven is reading <varname>top-group</varname>
      <acronym>POM</acronym> it will look at the modules element and see that
      <varname>top-group</varname> references the projects
      <varname>sub-group</varname> and <varname>project-c</varname>. Maven
      will then look for a <filename>pom.xml</filename> in each of these
      subdirectories. Maven repeats this process for each of the submodules:
      it will read the <filename>sub-group/pom.xml</filename> and see that the
      <varname>sub-group</varname> project references two projects with the
      following modules element:</para>

      <example>
        <title>sub-group modules element</title>

        <programlisting language="xml">&lt;project&gt;
  ...
  &lt;modules&gt;
    &lt;module&gt;project-a&lt;/module&gt;
    &lt;module&gt;project-b&lt;/module&gt;
  &lt;/modules&gt;
  ...
&lt;/project&gt;</programlisting>
      </example>

      <para>Note that we call the projects under the multi-module projects
      "modules" and not "children" or "child projects". This is purposeful, so
      as not to confuse projects grouped by multi-module projects with
      projects that inherit <acronym>POM</acronym> information from each
      other.</para>
    </section>

    <section id="pom-relationships-sect-project-inheritance">
      <title>Project Inheritance</title>

      <para>There are going to be times when you want a project to inherit
      values from a parent POM. You might be building a large system, and you
      don't want to have to repeat the same dependency elements over and over
      again. You can avoid repeating yourself if your projects make use of
      inheritance via the parent element. When a project specifies a parent,
      it inherits the information in the parent project's POM. It can then
      override and add to the values specified in this parent POM.</para>

      <para>All Maven <acronym>POM</acronym>s inherit values from a parent
      <acronym>POM</acronym>. If a <acronym>POM</acronym> does not specify a
      direct parent using the <sgmltag>parent</sgmltag> element, that
      <acronym>POM</acronym> will inherit values from the Super
      <acronym>POM</acronym>. <xref linkend="ex-inheritance" /> shows the
      <sgmltag>parent</sgmltag> element of <varname>project-a</varname> which
      inherits the <acronym>POM</acronym> defined by the
      <varname>a-parent</varname> project.</para>

      <example id="ex-inheritance">
        <title>Project Inheritance</title>

        <programlisting language="xml">&lt;project&gt;
  &lt;parent&gt;
    &lt;groupId&gt;com.training.killerapp&lt;/groupId&gt;
    &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
  ...
&lt;/project&gt;
</programlisting>
      </example>

      <para>Running <command>mvn help:effective-pom</command> in
      <varname>project-a</varname> would show a <acronym>POM</acronym> that is
      the result of merging the Super <acronym>POM</acronym> with the
      <acronym>POM</acronym> defined by <varname>a-parent</varname> and the
      <acronym>POM</acronym> defined in <varname>project-a</varname>. The
      implicit and explicit inheritance relationships for
      <varname>project-a</varname> are shown in <xref
      linkend="fig-inheritance" />.<figure id="fig-inheritance">
          <title>Project Inheritance for a-parent and project-a</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/web/pom_inheritance.png" />
            </imageobject>
          </mediaobject>
        </figure>When a project specifies a parent project, Maven uses that
      parent <acronym>POM</acronym> as a starting point before it reads the
      current project's <acronym>POM</acronym>. It inherits everything,
      including the <varname>groupId</varname> and <varname>version</varname>
      number. You'll notice that <varname>project-a</varname> does not specify
      either, both <varname>groupId</varname> and <varname>version</varname>
      are inherited from <varname>a-parent</varname>. With a parent element,
      all a <acronym>POM</acronym> really needs to define is an
      <varname>artifactId</varname>. This isn't mandatory,
      <varname>project-a</varname> could have a different
      <varname>groupId</varname> and <varname>version</varname>, but by not
      providing values, Maven will use the values specified in the parent
      <acronym>POM</acronym>. If you start using Maven to manage and build
      large multi-module projects, you will often be creating many projects
      which share a common <varname>groupId</varname> and
      <varname>version</varname>.</para>

      <para>When you inherit a <acronym>POM</acronym>, you can choose to live
      with the inherited <acronym>POM</acronym> information or to selectively
      override it. The following is a list of items a Maven
      <acronym>POM</acronym> inherits from its parent
      <acronym>POM</acronym>:</para>

      <itemizedlist>
        <listitem>
          <para>identifiers (at least one of <varname>groupId</varname> or
          <varname>artifactId</varname> must be overridden.)</para>
        </listitem>

        <listitem>
          <para>dependencies</para>
        </listitem>

        <listitem>
          <para>developers and contributors</para>
        </listitem>

        <listitem>
          <para>plugin lists</para>
        </listitem>

        <listitem>
          <para>reports lists</para>
        </listitem>

        <listitem>
          <para>plugin executions (executions with matching ids are
          merged)</para>
        </listitem>

        <listitem>
          <para>plugin configuration</para>
        </listitem>
      </itemizedlist>

      <para>When Maven inherits dependencies, it will add dependencies of
      child projects to the dependencies defined in parent projects. You can
      use this feature of Maven to specify widely used dependencies across all
      projects which inherit from a top-level <acronym>POM</acronym>. For
      example, if your system makes universal use of the Log4J logging
      framework, you can list this dependency in your top-level
      <acronym>POM</acronym>. Any projects which inherit
      <acronym>POM</acronym> information from this project will automatically
      have Log4J as a dependency. Similarly, if you need to make sure that
      every project is using the same version of a Maven plugin, you can list
      this Maven plugin version explicitly in a top-level parent
      <acronym>POM</acronym>'s <sgmltag>pluginManagement</sgmltag>
      section.</para>

      <para>Maven assumes that the parent <acronym>POM</acronym> is available
      from the local repository, or available in the parent directory
      (<filename>../pom.xml</filename>) of the current project. If neither
      location is valid this default behavior may be overridden via the
      <sgmltag>relativePath</sgmltag> element. For example, some organizations
      prefer a flat project structure where a parent project's
      <filename>pom.xml</filename> isn't in the parent directory of a child
      project. It might be in a sibling directory to the project. If your
      child project were in a directory <filename>./project-a</filename> and
      the parent project were in a directory named
      <filename>./a-parent</filename>, you could specify the relative location
      of <varname>parent-a</varname>'s <acronym>POM</acronym> with the
      following configuration:</para>

      <programlisting language="xml">&lt;project&gt;
  &lt;parent&gt;
    &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
    &lt;artifactId&gt;a-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;relativePath&gt;../a-parent/pom.xml&lt;/relativePath&gt;
  &lt;/parent&gt;
  &lt;artifactId&gt;project-a&lt;/artifactId&gt;
&lt;/project&gt;</programlisting>
    </section>
  </section>

  <section id="pom-relationships-sect-pom-best-practice">
    <title>POM Best Practices</title>

    <para>Maven can be used to manage everything from simple, single-project
    systems to builds that involve hundreds of inter-related submodules. Part
    of the learning process with Maven isn't just figuring out the syntax for
    configuring Maven, it is learning the "Maven Way"—the current set of best
    practices for organizing and building projects using Maven. This section
    attempts to distill some of this knowledge to help you adopt best
    practices from the start without having to wade through years of
    discussions on the Maven mailing lists.</para>

    <section id="pom-relationships-sect-grouping-deps">
      <title>Grouping Dependencies</title>

      <para>If you have a set of dependencies which are logically grouped
      together. You can create a project with pom packaging that groups
      dependencies together. For example, let's assume that your application
      uses Hibernate, a popular Object-Relational mapping framework. Every
      project which uses Hibernate might also have a dependency on the Spring
      Framework and a MySQL <acronym>JDBC</acronym> driver. Instead of having
      to include these dependencies in every project that uses Hibernate,
      Spring, and MySQL you could create a special <acronym>POM</acronym> that
      does nothing more than declare a set of common dependencies. You could
      create a project called <varname>persistence-deps</varname> (short for
      Persistence Dependencies), and have every project that needs to do
      persistence depend on this convenience project:</para>

      <para><example>
          <title>Consolidating Dependencies in a Single POM Project</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
  &lt;artifactId&gt;persistence-deps&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;packaging&gt;pom&lt;/packaging&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate&lt;/artifactId&gt;
      &lt;version&gt;\${hibernateVersion}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
      &lt;artifactId&gt;hibernate-annotations&lt;/artifactId&gt;
      &lt;version&gt;\${hibernateAnnotationsVersion}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-hibernate3&lt;/artifactId&gt;
      &lt;version&gt;\${springVersion}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;mysql&lt;/groupId&gt;
      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
      &lt;version&gt;\${mysqlVersion}&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;properties&gt;
    &lt;mysqlVersion&gt;(5.1,)&lt;/mysqlVersion&gt;
    &lt;springVersion&gt;(2.0.6,)&lt;/springVersion&gt;
    &lt;hibernateVersion&gt;3.2.5.ga&lt;/hibernateVersion&gt;
    &lt;hibernateAnnotationsVersion&gt;3.3.0.ga&lt;/hibernateAnnotationsVersion&gt;
  &lt;/properties&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>If you create this project in a directory named
      <varname>persistence-deps</varname>, all you need to do is create this
      <filename>pom.xml</filename> and run <command>mvn install</command>.
      Since the packaging type is <varname>pom</varname>, this POM is
      installed in your local repository. You can now add this project as a
      dependency and all of its dependencies will be added to your project.
      When you declare a dependency on this persistence-deps project, don't
      forget to specify the dependency type as pom.</para>

      <para><example>
          <title>Declaring a Dependency on a POM</title>

          <programlisting language="xml">&lt;project&gt;
  &lt;description&gt;This is a project requiring JDBC&lt;/description&gt;
  ...
  &lt;dependencies&gt;
    ...
    &lt;dependency&gt;
      &lt;groupId&gt;org.sonatype.mavenbook&lt;/groupId&gt;
      &lt;artifactId&gt;persistence-deps&lt;/artifactId&gt;
      &lt;version&gt;1.0&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>If you later decide to switch to a different
      <acronym>JDBC</acronym> driver (for example, <acronym>JTDS</acronym>),
      just replace the dependencies in the <varname>persistence-deps</varname>
      project to use
      <varname>net.</varname><varname>sourceforge.jtds:jtds</varname> instead
      of <varname>mysql:mysql-java-connector</varname> and update the version
      number. All projects depending on <varname>persistence-deps</varname>
      will use <acronym>JTDS</acronym> if they decide to update to the newer
      version. Consolidating related dependencies is a good way to cut down on
      the length of <filename>pom.xml</filename> files that start having to
      depend on a large number of dependencies. If you need to share a large
      number of dependencies between projects, you could also just establish
      parent-child relationships between projects and refactor all common
      dependencies to the parent project, but the disadvantage of the
      parent-child approach is that a project can have only one parent.
      Sometimes it makes more sense to group similar dependencies together and
      reference a <literal>pom</literal> dependency. This way, your project
      can reference as many of these consolidated dependency
      <acronym>POM</acronym>s as it needs.</para>

      <note>
        <para>Maven uses the depth of a dependency in the tree when resolving
        conflicts using a nearest-wins approach. Using the dependency grouping
        technique above pushes those dependencies one level down in the tree.
        Keep this in mind when choosing between grouping in a pom or using
        <sgmltag>dependencyManagement</sgmltag> in a parent
        <acronym>POM</acronym></para>
      </note>
    </section>

    <section id="pom-relationships-sect-multi-vs-inherit">
      <title>Multi-module vs. Inheritance</title>

      <para>There is a difference between inheriting from a parent project
      and<indexterm>
          <primary>multimodule projects, in general</primary>

          <secondary>inheritance versus</secondary>
        </indexterm><indexterm>
          <primary>project inheritance</primary>

          <secondary>choosing multimodule projects instead of</secondary>
        </indexterm><indexterm>
          <primary>inheritance between projects or modules</primary>

          <secondary>choosing multimodule projects instead of</secondary>
        </indexterm><indexterm>
          <primary>module inheritance</primary>

          <secondary>choosing multimodule projects instead of</secondary>
        </indexterm> being managed by a multimodule project. A parent project
      is one that passes its values to its children. A multimodule project
      simply manages a group of other subprojects or modules. The multimodule
      relationship is defined from the topmost level downwards. When setting
      up a multimodule project, you are simply telling a project that its
      build should include the specified modules. Multimodule builds are to be
      used to group modules together in a single build. The parent-child
      relationship is defined from the leaf node upwards. The parent-child
      relationship deals more with the definition of a particular project.
      When you associate a child with its parent, you are telling Maven that a
      project’s <acronym>POM</acronym> is derived from another.</para>

      <para>To illustrate the decision process that goes into choosing a
      design that uses inheritance vs. multi-module or both approaches
      consider the following two examples: the Maven project used to generate
      this book and a hypothetical project that contains a number of logically
      grouped modules.</para>

      <section id="pom-relationships-sect-simple-project">
        <title>Simple Project</title>

        <para>First, let's take a look at the maven-book project. The
        inheritance and multi-module relationships are shown in <xref
        linkend="fig-maven-book" />.</para>

        <figure id="fig-maven-book">
          <title>maven-book Multi-module vs. Inheritance</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/web/pom_book-example.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>When we build this Maven book you are reading, we run
        <command>mvn package</command> in a multi-module project named
        <varname>maven-book</varname>. This multi-module project includes two
        submodules: <varname>book-examples</varname> and
        <varname>book-chapters</varname>. Neither of these projects share the
        same parent, they are related only in that they are modules in the
        <varname>maven-book</varname> project.
        <varname>book-examples</varname> builds the <acronym>ZIP</acronym> and
        <acronym>TGZ</acronym> archives you downloaded to get this book's
        example. When we run the <varname>book-examples</varname> build from
        <filename>book-examples/</filename> directory with <command>mvn
        package</command>, it has no knowledge that it is a part of the larger
        <varname>maven-book</varname> project.
        <varname>book-examples</varname> doesn't really care about
        <varname>maven-book</varname>, all it knows in life is that its parent
        is the top-most <varname>sonatype</varname> <acronym>POM</acronym> and
        that it creates an archive of examples. In this case, the
        <varname>maven-book</varname> project exists only as a convenience and
        as a aggregator of modules.</para>

        <para>The book projects do all define a parent. Each of the three
        projects: <varname>maven-book</varname>,
        <varname>book-examples</varname>, and <varname>book-chapters</varname>
        all list a shared "corporate" parent — <varname>sonatype</varname>.
        This is a common practice in organizations which have adopted Maven,
        instead of having every project extend the Super
        <acronym>POM</acronym> by default, some organizations define a
        top-level corporate <acronym>POM</acronym> that serves as the default
        parent when a project doesn't have any good reason to depend on
        another. In this book example, there is no compelling reason to have
        <varname>book-examples</varname> and <varname>book-chapters</varname>
        share the same parent <acronym>POM</acronym>, they are entirely
        different projects which have a different set of dependencies, a
        different build configuration, and use drastically different plugins
        to create the content you are now reading. The
        <varname>sonatype</varname> <acronym>POM</acronym> gives the
        organization a change to customize the default behavior of Maven and
        supply some organization-specific information to configure deployment
        settings and build profiles.</para>
      </section>

      <section id="pom-relationships-sect-multi-module-enterprise">
        <title>Multi-module Enterprise Project</title>

        <para>Let's take a look at an example that provides a more accurate
        picture of a real-world project where inheritance and multi-module
        relationships exist side by side. <xref linkend="fig-multi-module" />
        shows a collection of projects that resemble a typical set of projects
        in an enterprise application. There is a top-level
        <acronym>POM</acronym> for the corporation with an
        <varname>artifactId</varname> of <varname>sonatype</varname>. There is
        a multi-module project named <varname>big-system</varname> which
        references sub-modules <varname>server-side</varname> and
        <varname>client-side</varname>.</para>

        <figure id="fig-multi-module">
          <title>Enterprise Multi-module vs. Inheritance</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/web/pom_real_multi.png" />
            </imageobject>
          </mediaobject>
        </figure>

        <para>What's going on here? Let's try to deconstruct this confusing
        set of arrows. First, let's take a look at
        <varname>big-system</varname>. The <varname>big-system</varname> might
        be the project that you would run <command>mvn package</command> on to
        build and test the entire system. <varname>big-system</varname>
        references submodules <varname>client-side</varname> and
        <varname>server-side</varname>. Each of these projects effectively
        rolls up all of the code that runs on either the server or on the
        client. Let's focus on the <varname>server-side</varname> project.
        Under the <varname>server-side</varname> project we have a project
        called <varname>server-lib</varname> and a multi-module project named
        <varname>web-apps</varname>. Under <varname>web-apps</varname> we have
        two Java web applications: <varname>client-web</varname> and
        <varname>admin-web</varname>.</para>

        <para>Let's start with the parent/child relationships from
        <varname>client-web</varname> and <varname>admin-web</varname> to
        <varname>web-apps</varname>. Since both of the web applications are
        implemented in the same web application framework (let's say Wicket),
        both projects would share the same set of core dependencies. The
        dependencies on the Servlet <acronym>API</acronym>, the
        <acronym>JSP</acronym> <acronym>API</acronym>, and Wicket would all be
        captured in the <varname>web-apps</varname> project. Both
        <varname>client-web</varname> and <varname>admin-web</varname> also
        need to depend on <varname>server-lib</varname>, this dependency would
        be defined as a dependency between <varname>web-apps</varname> and
        <varname>server-lib</varname>. Because <varname>client-web</varname>
        and <varname>admin-web</varname> share so much configuration by
        inheriting from <varname>web-apps</varname>, both
        <varname>client-web</varname> and <varname>admin-web</varname> will
        have very small <acronym>POM</acronym>s containing little more than
        identifiers, a parent declaration, and a final build name.</para>

        <para>Next we focus on the parent/child relationship from
        <varname>web-apps</varname> and <varname>server-lib</varname> to
        <varname>server-side</varname>. In this case, let's just assume that
        there is a separate working group of developers which work on the
        server-side code and another group of developers that work on the
        client-side code. The list of developers would be configured in the
        <varname>server-side</varname> POM and inherited by all of the child
        projects underneath it: <varname>web-apps</varname>,
        <varname>server-lib</varname>, <varname>client-web</varname>, and
        <varname>admin-web</varname>. We could also imagine that the
        <varname>server-side</varname> project might have different build and
        deployment settings which are unique to the development for the server
        side. The <varname>server-side</varname> project might define a build
        profile that only makes sense for all of the
        <varname>server-side</varname> projects. This build profile might
        contain the database host and credentials, or the
        <varname>server-side</varname> project's <acronym>POM</acronym> might
        configure a specific version of the Maven Jetty plugin which should be
        universal across all projects that inherit the
        <varname>server-side</varname> <acronym>POM</acronym>.</para>

        <para>In this example, the main reason to use parent/child
        relationships is shared dependencies and common configuration for a
        group of projects which are logically related. All of the projects
        below <varname>big-system</varname> are related to one another as
        submodules, but not all submodules are configured to point back to
        parent project that included it as a submodule. Everything is a
        submodule for reasons of convenience, to build the entire system just
        go to the <varname>big-system</varname> project directory and run
        <command>mvn package</command>. Look more closely at the figure and
        you'll see that there is no parent/child relationship between
        <varname>server-side</varname> and <varname>big-system</varname>. Why
        is this? <acronym>POM</acronym> inheritance is very powerful, but it
        can be overused. When it makes sense to share dependencies and build
        configuration, a parent/child relationship should be used. When it
        doesn't make sense is when there are distinct differences between two
        projects. Take, for example, the <varname>server-side</varname> and
        <varname>client-side</varname> projects. It is possible to create a
        system where <varname>client-side</varname> and
        <varname>server-side</varname> inherited a common
        <acronym>POM</acronym> from <varname>big-system</varname>, but as soon
        as a significant divergence between the two child projects develops,
        you then have to figure out creative ways to factor out common build
        configuration to <varname>big-system</varname> without affecting all
        of the children. Even though <varname>client-side</varname> and
        <varname>server-side</varname> might both depend on Log4J, they also
        might have distinct plugin configurations.</para>

        <para>There's a certain point defined more by style and experience
        where you decide that minimal duplication of configuration is a small
        price to pay for allowing projects like <varname>client-side</varname>
        and <varname>server-side</varname> to remain completely independent.
        Designing a huge set of thirty plus projects which all inherit five
        levels of POM configuration isn't always the best idea. In such a
        setup, you might not have to duplicate your Log4J dependency more than
        once, but you'll also end up having to wade through five levels of POM
        just figure out how Maven calculated your effective POM. All of this
        complexity to avoid duplicating five lines of dependency declaration.
        In Maven, there is a "Maven Way", but there are also many ways to
        accomplish the same thing. It all boils down to preference and style.
        For the most part, you won't go wrong if all of your submodules turn
        out to define back-references to the same project as a parent, but
        your use of Maven may evolve over time.</para>
      </section>

      <section id="pom-relationships-prototype-parent">
        <title>Prototype Parent Projects</title>

        <para>Take the following example shown in <xref
        linkend="fig-multi-proto" /> as another hypothetical and creative way
        to use inheritance and multi-modules builds to reuse
        dependencies.<figure id="fig-multi-proto">
            <title>Using parent projects as "prototypes" for specialized
            projects</title>

            <mediaobject>
              <imageobject>
                <imagedata fileref="figs/web/pom_protos.png" />
              </imageobject>
            </mediaobject>
          </figure><xref linkend="fig-multi-proto" /> is yet another way to
        think about inheritance and multi-module projects. In this example,
        you have two distinct systems. <varname>system-a</varname> and
        <varname>system-b</varname> each define independent applications.
        <varname>system-a</varname> defines two modules
        <varname>a-lib</varname> and <varname>a-swing</varname>.
        <varname>system-a</varname> and <varname>a-lib</varname> both define
        the top-level <varname>sonatype</varname> <acronym>POM</acronym> as a
        parent project, but the <varname>a-swing</varname> project defines
        <varname>swing-proto</varname> as a parent project. In this system,
        <varname>swing-proto</varname> supplies a foundational
        <acronym>POM</acronym> for Swing applications and the
        <varname>struts-proto</varname> project provides a foundational
        <acronym>POM</acronym> for Struts 2 web applications. While the
        <varname>sonatype</varname> POM provides high level information such
        as the <varname>groupId</varname>, organization information, and build
        profiles, <varname>struts-proto</varname> defines all of the
        dependencies that you need to create a struts application. This
        approach would work well if your development is characterized by many
        independent applications which each have to follow the same set of
        rules. If you are creating a lot of struts applications but they are
        not really related to one another, you might just define everything
        you need in <varname>struts-proto</varname>. The downside to this
        approach is that you won't be able to use parent/child relationships
        within the <varname>system-a</varname> and <varname>system-b</varname>
        project hierarchies to share information like developers and other
        build configuration. A project can only have one parent.</para>

        <para>The other downside of this approach is that as soon as you have
        one project that "breaks the mold" you'll either have to override the
        prototype parent <acronym>POM</acronym> or find a way to factor
        customizations into the shared parent without those customizations
        affecting all the children. In general, using POMs as prototypes for
        specialized project "types" isn't a recommended practice.</para>
      </section>
    </section>
  </section>
</chapter>