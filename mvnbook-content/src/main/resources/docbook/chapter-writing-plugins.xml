<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="writing-plugins">
  <title>Writing Plugins</title>

  <section id="writing-plugins-sect-intro">
    <title>Introduction</title>

    <para>While this chapter covers an advanced topic, don't let the idea of
    writing a Maven plugin intimidate. For all of the theory and complexity of
    this tool, the fundamental concepts are easy to understand and the
    mechanics of writing a plugin are straightforward. After you read this
    chapter, you will have a better grasp of what is involved in creating a
    Maven plugin.</para>
  </section>

  <section id="writing-plugins-sect-programming-maven">
    <title>Programming Maven</title>

    <para>Most of this book has dealt with using Maven, and for a book on
    Maven, you haven't seen too many code examples dealing with Maven
    customization. In fact, you haven't yet seen any. This is by design, 99
    out of 100 Maven users will never need to write a custom plugin to
    customize Maven; there is an abundance of configurable plugins, and unless
    your project has particularly unique requirements, you will have to work
    to find a reason to write a new plugin. An even smaller percentage of
    people who end up writing custom plugins will ever need to crack open the
    source code for Maven and customize a core Maven component. If you really
    need to customize the behavior of Maven, then you would write a plugin.
    Modifying the core Maven code is as far out of scope for most developers
    as modifying the TCP/IP stack on an operating system, it is that abstract
    for most Maven users.</para>

    <para>On the other hand, if you are going to start writing a custom
    plugin, you are going to have to learn a bit about the internals of Maven:
    How does it manage software components? What is a Plugin? How can I
    customize the lifecycle? This section answers some of those questions, and
    it introduces a few concepts at the core of Maven's design. Learning how
    to write a custom Maven plugin is the gateway to customizing Maven itself.
    If you were wondering how to start understanding the code behind Maven,
    you've found the proper starting line.</para>

    <section id="writing-plugins-ioc">
      <title>What is Inversion of Control?</title>

      <para>At the heart of Maven is an Inversion of Control (IoC) container
      named Plexus. What does it do? It is a system for managing and relating
      components. While there is a canonical essay about IoC written by Martin
      Fowler, the concept and term have been so heavily overloaded in the past
      few years it is tough to find a good definition of the concept that
      isn't a self-reference (or just a lazy reference to the aforementioned
      essay). Instead of resorting to a Wikipedia quote, we'll summarize
      Inversion of Control and Dependency Injection with an analogy.</para>

      <para>Assume that you have a series of components which need to be wired
      together. When you think about components, think stereo components not
      software components. Imagine several stereo components hooked up to a
      Playstation 3 and a Tivo that have to interface with both an Apple TV
      box and a 50" flat panel LCD TV. You bring everything home from the
      electronics store and you purchase a series of cables that you are going
      to use to connect everything to everything else. You unpack all of these
      components, put them in the right place and then get to the job of
      hooking up fifty thousand coaxial cables and stereo jacks to fifty
      thousand digital inputs and network cables. Step back from your home
      entertainment center and turn on the TV, you've just performed
      dependency injection, and you've just been an inversion of control
      container.</para>

      <para>So what did that have to do with anything? Your Playstation 3 and
      a Java Bean both provide an interface. The Playstation 3 has two inputs:
      power and network, and one output to the TV. Your JavaBean has three
      properties: <varname>power</varname>, <varname>network</varname>, and
      <varname>tvOutput</varname>. When you open the box of your Playstation
      3, it didn't provide you with detailed pictures and instructions for how
      to connect it to every different kind of TV that might be in every
      different kind of house, and when you look at your Java Bean it just
      provides a set of properties, not an explicit recipe for creating and
      managing an entire system of components. In an IoC container like
      Plexus, you are responsible for declaring the relationships between a
      set of components which simply provide an interface of inputs and
      outputs. You don't instantiate objects, Plexus does; your application's
      code isn't responsible for managing the state of components, Plexus is.
      Even though it sounds very cheesy, when you start up Maven, it is
      starting Plexus and managing a system of related components just like
      your stereo system.</para>

      <para>What are the advantages of using an IoC container? What is the
      advantage of buying discrete stereo components? If one component breaks,
      you can drop in a replacement for your Playstation 3 without having to
      spend $20,000 on the entire system. If you are unhappy with your TV, you
      can swap it out without affecting your CD player. Most important to you,
      your stereo components cost less and are more capable and reliable
      because manufacturers can build to a set of known inputs and outputs and
      focus on building individual components. Inversion of Control containers
      and Dependency Injection encourage Disaggregation and the emergence of
      standards. The software industry likes to imagine itself as the font of
      all new ideas, but dependency injection and inversion of control are
      really just new words for the concepts of Disaggregation and
      interchangeable machinery. If you really want to know about DI and IoC,
      learn about the Model T, the Cotton Gin, and the emergence of a railroad
      standard in the late 19th century.</para>
    </section>

    <section id="writing-plugins-intro-plexus">
      <title>Introduction to Plexus</title>

      <para>The most important feature of an <acronym>IoC</acronym> container
      implemented in Java is a mechanism called dependency injection. The
      basic idea of <acronym>IoC</acronym> is that the control of creating and
      managing objects is removed from the code itself and placed into the
      hands of an <acronym>IoC</acronym> framework. Using dependency injection
      in an application that has been programmed to interfaces, you can create
      components which are not bound to specific implementations of these
      interfaces. Instead, you program to interfaces and then configure Plexus
      to connect the appropriate implementation to the appropriate component.
      While your code deals with interfaces, you can capture the dependencies
      between classes and components in an <acronym>XML</acronym> file that
      defines components, implementation classes, and the relationships
      between your components. In other words, you can write isolated
      components, then you can wire them together using an
      <acronym>XML</acronym> file that defines how the components are wired
      together. In the case of Plexus, system components are defined with an
      <acronym>XML</acronym> document that is found in
      <filename>META-INF/plexus/components.xml</filename>.</para>

      <para>In a Java <acronym>IoC</acronym> container, there are several
      methods for injecting dependencies values into a component object:
      constructor, setter, or field injections. Although Plexus is capable of
      all three dependency injection techniques, Maven only uses two types:
      field and setter injection.</para>

      <variablelist>
        <varlistentry>
          <term>Constructor Injection</term>

          <listitem>
            <para>Constructor injection is populating an object's values
            through its constructor when an instance of the object is created.
            For example, if you had an object of type
            <classname>Person</classname> which had a constructor
            <methodname>Person(String name, Job job)</methodname>, you could
            pass in values for both <varname>name</varname> and the
            <varname>job</varname> via this constructor.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Setter Injection</term>

          <listitem>
            <para>Setter injection is using the setter method of a property on
            a Java bean to populate object dependencies. For example, if you
            were working with a <classname>Person</classname> object with the
            properties <varname>name</varname> and <varname>job</varname>, an
            <acronym>IoC</acronym> container which uses setter injection,
            would create an instance of <classname>Person</classname> using a
            no-arg constructor. Once it had an instance of
            <classname>Person</classname>, it would proceed to call the
            <methodname>setName()</methodname> and
            <methodname>setJob()</methodname> methods.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Field Injection</term>

          <listitem>
            <para>Both Constructor and Setter injection rely on a call to a
            public method. Using Field injection, an <acronym>IoC</acronym>
            container populates a component's dependencies by setting an
            object's fields directly. For example, if you were working with a
            <classname>Person</classname> object that had two fields
            <varname>name</varname> and <varname>job</varname>, your
            <acronym>IoC</acronym> container would populate these dependencies
            by setting these fields directly (i.e. <code>person.name =
            "Thomas"; person.job = job;</code>)</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section id="writing-plugins-why-plexus">
      <title>Why Plexus?</title>

      <para>Spring does happen to be the most popular IoC container at the
      moment, and there's a good argument to be made that it has affected the
      Java "ecosystem" for the better forcing companies like Sun Microsystems
      to yield more control to the open source community and helping to open
      up standards by providing a pluggable, component-oriented "bus". But,
      Spring isn't the only IoC container in open source. There are many IoC
      containers (like <ulink
      url="http://www.picocontainer.org/">PicoContainer</ulink>).</para>

      <para>Years and years ago, when Maven was created, Spring wasn't a
      mature option. The initial team of committers on Maven were more
      familiar with Plexus because they invented it, so they decided to use it
      as an IoC container. While it might not be as popular as the Spring
      Framework, it is no less capable. And, the fact that it was created by
      the same person who created Maven makes it a perfect fit. After reading
      this chapter you've have an idea of how Plexus works. If you already use
      an IoC container you'll notice similarities and differences between
      Plexus and the container you currently use.</para>

      <note>
        <para>Just because Maven is based on Plexus doesn't mean that the
        Maven community is "anti-Spring" (we've included a whole chapter with
        a Spring example in this book, portions of the Spring project are
        moving to Maven as a build platform). The question, "Why didn't you
        use Spring?" comes up often enough it did make sense to address it
        here. We know it, Spring is a rock star, we don't deny it, and it is
        on our continuing to-do list to introduce people to (and document)
        Plexus: choice in the software industry is always a good thing.</para>
      </note>
    </section>

    <section id="writing-plugins-what-is-plugin">
      <title>What is a Plugin?</title>

      <para>A Maven Plugin is a Maven artifact which contains a plugin
      descriptor and one or more Mojos. A Mojo can be thought of as a goal in
      Maven, and every goal corresponds to a Mojo. The
      <varname>compiler:compile</varname> goal corresponds to the
      <classname>CompilerMojo</classname> class in the Maven Compiler Plugin,
      and the <varname>jar:jar</varname> goal corresponds to the
      <classname>JarMojo</classname> class in the Maven Jar Plugin. When you
      write your own plugin, you are simply grouping together a set of related
      Mojos (or goals) in a single plugin artifact.<footnote
          id="foot-mojo-def">
          <para>"mojo." The American HeritageÂ® Dictionary of the English
          Language, Fourth Edition. Houghton Mifflin Company, 2004.
          Answers.com 02 Mar. 2008. <ulink
          url="http://www.answers.com/topic/mojo-1">http://www.answers.com/topic/mojo-1</ulink></para>
        </footnote></para>

      <note>
        <para>Mojo? What is a Mojo? The word mojo<footnoteref
        linkend="foot-mojo-def" /> is defined as "a magic charm or spell", "an
        amulet, often in a small flannel bag containing one or more magic
        items", and "personal magnetism; charm". Maven uses the term Mojo
        because it is a play on the word Pojo (Plain-old Java Object).</para>
      </note>

      <para>A Mojo is much more than just a goal in Maven, it is a component
      managed by Plexus that can include references to other Plexus
      components.</para>
    </section>
  </section>

  <section id="writing-plugins-sect-plugin-descriptor">
    <title>Plugin Descriptor</title>

    <para>A Maven plugin contains a road-map for Maven that tells Maven about
    the various Mojos and plugin configuration. This plugin descriptor is
    present in the plugin <acronym>JAR</acronym> file in
    <filename>META-INF/maven/plugin.xml</filename>. When Maven loads a plugin,
    it reads this <acronym>XML</acronym> file, instantiates and configures
    plugin objects to make the Mojos contained in a plugin available to
    Maven.</para>

    <para>When you are writing custom Maven plugins, you will almost never
    need to think about writing a plugin descriptor. In <xref
    linkend="lifecycle" />, the lifecycle goals bound to the
    <varname>maven-plugin</varname> packaging type show that the
    <varname>plugin:descriptor</varname> goal is bound to the
    <varname>generate-resources</varname> phase. This goal generates a plugin
    descriptor off of the annotations present in a plugin's source code. Later
    in this chapter, you will see how Mojos are annotated, and you will also
    see how the values in these annotations end up in the
    <filename>META-INF/maven/plugin.xml</filename> file.</para>

    <para><xref linkend="ex-plugin-desc" /> shows a plugin descriptor for the
    Maven Zip Plugin. This plugin is a contrived plugin that simply zips up
    the output directory and produces an archive. Normally, you wouldn't need
    to write a custom plugin to create an archive from Maven, you could simply
    use the Maven Assembly Plugin which is capable of producing a distribution
    archive in multiple formats. Read through the following plugin descriptor
    to get an idea of the content it contains.</para>

    <!--TODO: Reference Assembly Plugin Chapter-->

    <example id="ex-plugin-desc">
      <title>Plugin Descriptor</title>

      <programlisting language="xml">&lt;plugin&gt;
  &lt;description&gt;&lt;/description&gt;
  &lt;groupId&gt;com.training.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-zip-plugin&lt;/artifactId&gt;
  &lt;version&gt;1-SNAPSHOT&lt;/version&gt;
  &lt;goalPrefix&gt;zip&lt;/goalPrefix&gt;
  &lt;isolatedRealm&gt;false&lt;/isolatedRealm&gt;
  &lt;inheritedByDefault&gt;true&lt;/inheritedByDefault&gt;
  &lt;mojos&gt;
    &lt;mojo&gt;
      &lt;goal&gt;zip&lt;/goal&gt;
      &lt;description&gt;Zips up the output directory.&lt;/description&gt;
      &lt;requiresDirectInvocation&gt;false&lt;/requiresDirectInvocation&gt;
      &lt;requiresProject&gt;true&lt;/requiresProject&gt;
      &lt;requiresReports&gt;false&lt;/requiresReports&gt;
      &lt;aggregator&gt;false&lt;/aggregator&gt;
      &lt;requiresOnline&gt;false&lt;/requiresOnline&gt;
      &lt;inheritedByDefault&gt;true&lt;/inheritedByDefault&gt;
      &lt;phase&gt;package&lt;/phase&gt;
      &lt;implementation&gt;com.training.plugins.ZipMojo&lt;/implementation&gt;
      &lt;language&gt;java&lt;/language&gt;
      &lt;instantiationStrategy&gt;per-lookup&lt;/instantiationStrategy&gt;
      &lt;executionStrategy&gt;once-per-session&lt;/executionStrategy&gt;
      &lt;parameters&gt;
        &lt;parameter&gt;
          &lt;name&gt;baseDirectory&lt;/name&gt;
          &lt;type&gt;java.io.File&lt;/type&gt;
          &lt;required&gt;false&lt;/required&gt;
          &lt;editable&gt;true&lt;/editable&gt;
          &lt;description&gt;Base directory of the project.&lt;/description&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
          &lt;name&gt;buildDirectory&lt;/name&gt;
          &lt;type&gt;java.io.File&lt;/type&gt;
          &lt;required&gt;false&lt;/required&gt;
          &lt;editable&gt;true&lt;/editable&gt;
          &lt;description&gt;Directory containing the build files.&lt;/description&gt;
        &lt;/parameter&gt;
      &lt;/parameters&gt;
      &lt;configuration&gt;
        &lt;buildDirectory implementation="java.io.File"&gt;
          \${project.build.directory}&lt;/buildDirectory&gt;
        &lt;baseDirectory implementation="java.io.File"&gt;
          \${basedir}&lt;/baseDirectory&gt;
      &lt;/configuration&gt;
      &lt;requirements&gt;
        &lt;requirement&gt;
          &lt;role&gt;org.codehaus.plexus.archiver.Archiver&lt;/role&gt;
          &lt;role-hint&gt;zip&lt;/role-hint&gt;
          &lt;field-name&gt;zipArchiver&lt;/field-name&gt;
        &lt;/requirement&gt;
      &lt;/requirements&gt;
    &lt;/mojo&gt;
  &lt;/mojos&gt;
  &lt;dependencies&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
  &lt;/dependencies&gt;
&lt;/plugin&gt;
</programlisting>
    </example>

    <para>There are three parts to a plugin descriptor: the top-level
    configuration of the plugin which contains elements like
    <sgmltag>groupId</sgmltag> and <sgmltag>artifactId</sgmltag>, the
    declaration of mojos, and the declaration of dependencies. Let's examine
    each of these sections in more detail.</para>

    <section id="writing-plugins-top-level-elements">
      <title>Top-level Plugin Descriptor Elements</title>

      <para>The top-level configuration values in the
      <sgmltag>plugin</sgmltag> element are:</para>

      <variablelist>
        <varlistentry>
          <term>description</term>

          <listitem>
            <para>This element contains a short description of the plugin. In
            the case of the Zip plugin, this description is empty.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>groupId, artifactId, version</term>

          <listitem>
            <para>Just like everything else in Maven, plugins need to have a
            unique coordinate. The groupId, artifactId, and version are used
            to locate the plugin artifact in a Maven repository.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>goalPrefix</term>

          <listitem>
            <para>This element controls the prefix used to reference goals in
            a particular plugin. If you were to look at the Compiler plugin's
            descriptor you would see that <varname>goalPrefix</varname> has a
            value of <varname>compiler</varname>, and if you look at the
            descriptor for the Jar plugin, it would have a
            <varname>goalPrefix</varname> of <varname>jar</varname>. It is
            important that you choose a distinct goal prefix for your custom
            plugin.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>isolatedRealm (deprecated)</term>

          <listitem>
            <para>This is a legacy property which is no longer used by Maven.
            It is still present in the system to provide for backwards
            compatibility with older plugins. Earlier versions of Maven used
            to provide a mechanism to load a plugin's dependencies in an
            isolated <classname>ClassLoader</classname>. Maven makes extensive
            use of a project called <ulink
            url="http://classworlds.codehaus.org/">ClassWorlds</ulink> from
            the <ulink url="http://www.codehaus.org">Codehaus</ulink>
            community to create hierarchies of
            <classname>ClassLoader</classname> objects which are modeled by a
            <classname>ClassRealm</classname> object. Feel free to ignore this
            property and always set it to <varname>false</varname>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>inheritedByDefault</term>

          <listitem>
            <para>If inheritedByDefault is set to true, any mojo in this
            plugin which is configured in a parent project will be configured
            in a child project. If you configure a mojo to execute during a
            specific phase in a parent project and the Plugin has
            inheritedByDefault set to true, this execution will be inherited
            by the child project. If inheritedByDefault is not set to true,
            then an goal execution defined in a parent project will not be
            inherited by a child project.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section id="writing-plugins-sect-mojo-config">
      <title>Mojo Configuration</title>

      <para>Next is the declaration of the each Mojo. The plugin element
      contains an element named mojos which contains a mojo element for each
      mojo present in the Plugin. Each mojo element contains the following
      configuration elements:</para>

      <variablelist>
        <varlistentry>
          <term>goal</term>

          <listitem>
            <para>This is the name of the goal. If you were running the
            <varname>compiler:compile</varname> goal, then
            <varname>compiler</varname> is the plugin's
            <varname>goalPrefix</varname> and <varname>compile</varname> would
            be the name of the goal.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>description</term>

          <listitem>
            <para>This contains a short description of the goal to display to
            the use when they use the Help plugin to generate plugin
            documentation.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>requiresDirectInvocation</term>

          <listitem>
            <para>If you set this to <varname>true</varname>, the goal can
            only be executed if it is explicitly executed from the
            command-line by the user. If someone tries to bind this goal to a
            lifecycle phase in a <acronym>POM</acronym>, Maven will print an
            error message. The default for this element is
            <varname>false</varname>.</para>

            <!--TODO: Might want some justification.-->
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>requiresProject</term>

          <listitem>
            <para>Specifies that a given goal cannot be executed outside of a
            project. The goal requires a project with a
            <acronym>POM</acronym>. The default value for this
            <varname>requiresProject</varname> is
            <varname>true</varname>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>requiresReports</term>

          <listitem>
            <para>If you were creating a plugin that relies on the presence of
            reports, you would need to set <varname>requiresReports</varname>
            to <varname>true</varname>. For example, if you were writing a
            plugin to aggregate information from a number of reports, you
            would set <varname>requiresReports</varname> to
            <varname>true</varname>. The default for this element is
            <varname>false</varname>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>aggregator</term>

          <listitem>
            <para>A Mojo descriptor with <varname>aggregator</varname> set to
            <varname>true</varname> is supposed to only run once during the
            execution of Maven, it was created to give plugin developers the
            ability to summarize the output of a series of builds; for
            example, to create a plugin that summarizes a report across all
            projects included in a build. A goal with
            <varname>aggregator</varname> set to <varname>true</varname>
            should only be run against the top-level project in a Maven build.
            The default value of <varname>aggregator</varname> is
            <varname>false</varname>. Aggregator is slated for deprecation in
            a future release of Maven.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>requiresOnline</term>

          <listitem>
            <para>Specifies that a given goal cannot be executed if Maven is
            running in offline mode (<varname>-o</varname> command-line
            option). If a goal depends on a network resource, you would
            specify a value of <varname>true</varname> for this element and
            Maven would print an error if the goal was executed in offline
            mode. The default for <varname>requiresOnline</varname> is
            <varname>false</varname>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>inheritedByDefault</term>

          <listitem>
            <para>If <varname>inheritedByDefault</varname> is set to
            <varname>true</varname>, a mojo which is configured in a parent
            project will be configured in a child project. If you configure a
            mojo to execute during a specific phase in a parent project and
            the Mojo descriptor has <varname>inheritedByDefault</varname> set
            to <varname>true</varname>, this execution will be inherited by
            the child project. If <varname>inheritedByDefault</varname> is not
            set to <varname>true</varname>, then a goal execution defined in a
            parent project will not be inherited by a child project.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>phase</term>

          <listitem>
            <para>If you don't bind this goal to a specific phase, this
            element defines the default phase for this mojo. If you do not
            specify a phase element, Maven will require the user to explicitly
            specify a phase in a <acronym>POM</acronym>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>implementation</term>

          <listitem>
            <para>This element tells Maven which class to instantiate for this
            Mojo. This is a Plexus component property (defined in Plexus
            <classname>ComponentDescriptor</classname>).</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>language</term>

          <listitem>
            <para>The default language for a Maven Mojo is
            <varname>java</varname>. This controls the Plexus
            <classname>ComponentFactory</classname> used to create instances
            of this Mojo component. This chapter focuses on writing Maven
            plugins in Java, but you can also write Maven in a number of
            alternative languages such as Groovy, Beanshell, and Ruby. If you
            were writing a plugin in one of these languages you would use a
            language element value other than <varname>java</varname>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>instantiationStrategy</term>

          <listitem>
            <para>This property is a Plexus component configuration property,
            it tells Plexus how to create and manage instances of the
            component. In Maven, all mojos are going to be configured with an
            <varname>instantiationStrategy</varname> of
            <varname>per-lookup</varname>; a new instance of the component
            (mojo) is created every time it is retrieved from Plexus.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>executionStrategy</term>

          <listitem>
            <para>The execution strategy tells Maven when and how to execute a
            Mojo. The valid values are <varname>once-per-session</varname> and
            <varname>always</varname>. Honestly, the valid values are
            anything, this particular property doesn't do a thing, it is a
            hold over from an early design of Maven. This property is slated
            for deprecation in a future release of Maven.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>parameters</term>

          <listitem>
            <para>This element describes all of the parameters for this Mojo.
            What's the name of the parameter What is the type of parameter? Is
            it required? Each parameter has the following elements:</para>

            <variablelist>
              <varlistentry>
                <term>name</term>

                <listitem>
                  <para>Is the name of the parameter (i.e.
                  <varname>baseDirectory</varname>)</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>type</term>

                <listitem>
                  <para>This is the type (Java class) of the parameters (i.e.
                  <classname>java.io.File</classname>)</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>required</term>

                <listitem>
                  <para>Is the parameter required? If <varname>true</varname>,
                  the parameter must be non-null when the goal is
                  executed.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>editable</term>

                <listitem>
                  <para>If a parameter is not editable (if
                  <varname>editable</varname> is set to
                  <varname>false</varname>), then the value of the parameter
                  cannot be set in the <acronym>POM</acronym>. For example, if
                  the plugin descriptor defines the value of
                  <varname>buildDirectory</varname> to be
                  <varname>\${basedir}</varname> in the descriptor, a
                  <acronym>POM</acronym> cannot override this value to be
                  another value in a <acronym>POM</acronym>.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>description</term>

                <listitem>
                  <para>A short description to use when generating plugin
                  documentation (using the Help Plugin)</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>configuration</term>

          <listitem>
            <para>This element provides default values for all of the Mojo's
            parameters using Maven property notation. This example provides a
            default value for the <varname>baseDir</varname> Mojo parameter
            and the <varname>buildDirectory</varname> Mojo parameter. In the
            parameter element, the implementation specifies the type of the
            parameter (in this case <classname>java.io.File</classname>), the
            value in the parameter element contains either a hard-coded
            default or a Maven property reference.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>requirements</term>

          <listitem>
            <para>This is where the descriptor gets interesting. A Mojo is a
            component that is managed by Plexus, and, because of this, it has
            the opportunity to reference other components managed by Plexus.
            This element allows you to define dependencies on other components
            in Plexus.</para>

            <!--TODO: Insert an XREF to an example?-->
          </listitem>
        </varlistentry>
      </variablelist>

      <para>While you should know how to read a Plugin Descriptor, you will
      almost never need to write one of these descriptor files by hand. Plugin
      Descriptor files are generated automatically off of a set of annotations
      in the source for a Mojo.</para>
    </section>

    <section id="writing-plugins-sect-plugin-depend">
      <title>Plugin Dependencies</title>

      <para>Lastly, the plugin descriptor declares a set of dependencies just
      like a Maven project. When Maven uses a plugin, it will download any
      required dependencies before it attempts to execute a goal from this
      plugin. In this example, the plugin depends on Jakarta Commons IO
      version 1.3.2.</para>
    </section>
  </section>

  <section id="writing-plugins-sect-custom-plugin">
    <title>Writing a Custom Plugin</title>

    <para>When you write a custom plugin, you are going to be writing a series
    of Mojos (goals). Every Mojo is a single Java class which contains a
    series of annotations that tell Maven how to generate the Plugin
    descriptor described in the previous section. Before you can start writing
    Mojo classes, you will need to create Maven project with the appropriate
    packaging and POM.</para>

    <section id="writing-plugins-sect-creating-plugin-project">
      <title>Creating a Plugin Project</title>

      <para>To create a plugin project, you should use the Maven Archetype
      plugin. The following command-line will create a plugin with a
      <varname>groupId</varname> of
      <varname>org.sonatype.mavenbook.plugins</varname> and the
      <varname>artifactId</varname> of
      <varname>first-maven-plugin</varname>:</para>

      <screen>$ <command>mvn archetype:create \
  -DgroupId=org.sonatype.mavenbook.plugins \
  -DartifactId=first-maven-plugin \
  -DarchetypeGroupId=org.apache.maven.archetypes \
  -DarchetypeArtifactId=maven-archetype-mojo</command></screen>

      <para>The Archetype plugin is going to create a directory named
      my-first-plugin which contains the following POM.</para>

      <example>
        <title>A Plugin Project's POM</title>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;first-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;maven-plugin&lt;/packaging&gt;
  &lt;name&gt;first-maven-plugin Maven Mojo&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;
      &lt;artifactId&gt;maven-plugin-api&lt;/artifactId&gt;
      &lt;version&gt;2.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>The most import element in a plugin project's
      <acronym>POM</acronym> is the packaging element which has a value of
      <varname>maven-plugin</varname>. This packaging element customizes the
      Maven lifecycle to include the necessary goals to create a plugin
      descriptor. The plugin lifecycle was introduce in <xref
      linkend="lifecycle-sect-plugin-lifecycle" />, it is similar to the Jar
      lifecycle with three exceptions: <varname>plugin:descriptor</varname> is
      bound to the <varname>generate-resources</varname> phase,
      <varname>plugin:addPluginArtifactMetadata</varname> is added to the
      <varname>package</varname> phase, and
      <varname>plugin:updateRegistry</varname> is added to the
      <varname>install</varname> phase.</para>

      <para>The other important piece of a plugin project's
      <acronym>POM</acronym> is the dependency on the Maven Plugin API. This
      project depends on version 2.0 of the
      <varname>maven-plugin-api</varname> and it also adds in JUnit as a
      test-scoped dependency.</para>
    </section>

    <section id="writing-plugins-simple-java-mojo">
      <title>A Simple Java Mojo</title>

      <para>In this chapter, we're going to introduce a Maven Mojo written in
      Java. Each Mojo in your project is going to implement the
      <classname>org.apache.maven.plugin.Mojo</classname> interface, the
      <classname>Mojo</classname> implementation shown in the following
      example implements the Mojo interface by extending the
      <classname>org.apache.maven.plugin.AbstractMojo</classname> class.
      Before we dive into the code for this Mojo, let's take some time to
      explore the methods on the Mojo interface. Mojo provides the following
      methods:</para>

      <variablelist>
        <varlistentry>
          <term><methodname>void setLog( org.apache.maven.monitor.logging.Log
          log )</methodname></term>

          <listitem>
            <para>Every <classname>Mojo</classname> implementation has to
            provide a way for the plugin to communicate the progress of a
            particular goal. Did the goal succeed? Or, was there a problem
            during goal execution? When Maven loads and executes a Mojo, it is
            going to call the <methodname>setLog()</methodname> method and
            supply the Mojo instance with a suitable logging destination to be
            used in your custom plugin.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>protected Log getLog()</methodname></term>

          <listitem>
            <para>Maven is going to call <methodname>setLog()</methodname>
            before your <classname>Mojo</classname> is executed, and your
            <classname>Mojo</classname> can retrieve the logging object by
            calling <methodname>getLog()</methodname>. Instead of printing out
            status to Standard Output or the console, your
            <classname>Mojo</classname> is going to invoke methods on the
            <classname>Log</classname> object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>void execute() throws
          org.apache.maven.plugin.MojoExecutionException</methodname></term>

          <listitem>
            <para>This method is called by Maven when it is time to execute
            your goal.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>The <classname>Mojo</classname> interface is concerned with two
      things: logging the results of goal execution and executing a goal. When
      you are writing a custom plugin, you'll be extending
      <classname>AbstractMojo</classname>. <classname>AbstractMojo</classname>
      takes care of handling the <varname>setLog()</varname> and
      <varname>getLog()</varname> implementations and contains an abstract
      <methodname>execute()</methodname> method. When you extend
      <classname>AbstractMojo</classname>, all you need to do is implement the
      <methodname>execute()</methodname> method. <xref
      linkend="ex-simple-echomojo" /> shows a trivial
      <classname>Mojo</classname> implement which simply prints out a message
      to the console.</para>

      <example id="ex-simple-echomojo">
        <title>A Simple EchoMojo</title>

        <programlisting language="java">package org.sonatype.mavenbook.plugins;

import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;

/**
 * Echos an object string to the output screen.
 * @goal echo
 * @requiresProject false
 */
public class EchoMojo extends AbstractMojo
{
    /**
     * Any Object to print out.
     * @parameter expression="\${echo.message}" default-value="Hello World..."
     */
    private Object message;

    public void execute()
        throws MojoExecutionException, MojoFailureException
    {
        getLog().info( message.toString() );
    }
}
</programlisting>
      </example>

      <para>If you create this Mojo in <varname>\${basedir}</varname> under
      <filename>src/main/java</filename> in
      <filename>org/sonatype/mavenbook/mojo/EchoMojo.java</filename> in the
      project created in the previous section and run <command>mvn
      install</command>, you should be able to invoke this goal directly from
      the command-line with:</para>

      <screen>$ <command>mvn org.sonatype.mavenbook.plugins:first-maven-plugin:1.0-SNAPSHOT:echo</command></screen>

      <para>That large command-line is <command>mvn</command> followed by the
      <varname>groupId:artifactId:version:goal</varname>. When you run this
      command-line you should see output that contains the output of the echo
      goal with the default message: "Hello Maven World...". If you want to
      customize the message, you can pass the value of the message parameter
      with the following command-line:</para>

      <screen>$ <command>mvn org.sonatype.mavenbook.plugins:first-maven-plugin:1.0-SNAPSHOT:echo \
             -Decho.message="The Eagle has Landed"</command></screen>

      <para>The previous command-line is going to execute the
      <classname>EchoMojo</classname> and print out the message "The Eagle has
      Landed".</para>
    </section>

    <section id="writing-plugins-sect-plugin-prefix">
      <title>Configuring a Plugin Prefix</title>

      <para>Specifying the <varname>groupId</varname>,
      <varname>artifactId</varname>, <varname>version</varname>, and
      <varname>goal</varname> on the command-line is cumbersome. To address
      this, Maven assigns a plugin a prefix. Instead of typing:</para>

      <screen>$ mvn org.apache.maven.plugins:maven-jar-plugin:2.2:jar</screen>

      <para>You can use the plugin prefix <varname>jar</varname> and turn that
      command-line into <command>mvn jar:jar</command>. How does Maven resolve
      something like <varname>jar:jar</varname> to
      <varname>org.apache.mven.plugins:maven-jar:2.3</varname>? Maven looks at
      a file in the Maven repository to obtain a list of plugins for a
      specific <varname>groupId</varname>. By default, Maven is configured to
      look for plugins in two groups:
      <varname>org.apache.maven.plugins</varname> and
      <varname>org.codehaus.mojo</varname>. When you specify a new plugin
      prefix like <command>mvn hibernate3:hbm2ddl</command>, Maven is going to
      scan the repository metadata for the appropriate plugin prefix. First,
      Maven is going to scan the <varname>org.apache.maven.plugins</varname>
      group for the plugin prefix <varname>hibernate3</varname>. If it doesn't
      find the plugin prefix <varname>hibernate3</varname> in the
      <varname>org.apache.maven.plugins</varname> group it will scan the
      metadata for the <varname>org.codehaus.mojo</varname> group.</para>

      <para>When Maven scans the metadata for a particular
      <varname>groupId</varname>, it is retrieving an <acronym>XML</acronym>
      file from the Maven repository which captures metadata about the
      artifacts contained in a group. This <acronym>XML</acronym> file is
      specific for each repository referenced, if you are not using a custom
      Maven repository, you will be able to see the Maven metadata for the
      <varname>org.apache.maven.plugins</varname> group in your local Maven
      repository (<filename>~/.m2/repository</filename>) under
      <filename>org/apache/maven/plugins/maven-metadata-central.xml</filename>.
      <xref linkend="ex-maven-metadata" /> shows a snippet of the
      <filename>maven-metadata-central.xml</filename> file from the
      <varname>org.apache.maven.plugin</varname> group.</para>

      <example id="ex-maven-metadata">
        <title>Maven Metadata for the Maven Plugin Group</title>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;metadata&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;name&gt;Maven Clean Plugin&lt;/name&gt;
      &lt;prefix&gt;clean&lt;/prefix&gt;
      &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
    &lt;plugin&gt;
      &lt;name&gt;Maven Compiler Plugin&lt;/name&gt;
      &lt;prefix&gt;compiler&lt;/prefix&gt;
      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
    &lt;plugin&gt;
      &lt;name&gt;Maven Surefire Plugin&lt;/name&gt;
      &lt;prefix&gt;surefire&lt;/prefix&gt;
      &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
    ...
  &lt;/plugins&gt;
&lt;/metadata&gt;</programlisting>
      </example>

      <para>As you can see in <xref linkend="ex-maven-metadata" />, this
      <filename>maven-metadata-central.xml</filename> file in your local
      repository is what makes it possible for your to execute <command>mvn
      surefire:test</command>. Maven scans
      <varname>org.apache.maven.plugins</varname> and
      <varname>org.codehaus.mojo</varname>: plugins from
      <varname>org.apache.maven.plugins</varname> are considered core Maven
      plugins and plugins from <varname>org.codehaus.mojo</varname> are
      considered extra plugins. The Apache Maven project manages the
      <varname>org.apache.maven.plugins</varname> group, and a separate
      independent open source community manages the Codehaus Mojo project. If
      you would like to start publishing plugins to your own
      <varname>groupId</varname>, and you would like Maven to automatically
      scan your own <varname>groupId</varname> for plugin prefixes, you can
      customize the groups that Maven scans for plugins in your Maven
      Settings.</para>

      <para>If you wanted to be able to run the
      <varname>first-maven-plugin</varname>'s echo goal by running
      <varname>first:echo</varname>, add the
      <varname>org.sonatype.mavenbook.plugins</varname> groupId to your
      <filename>~/.m2/settings.xml</filename> as shown in <xref
      linkend="ex-plugin-groups" />. This will prepend the
      <varname>org.sonatype.mavenbook.plugins</varname> to the list of groups
      which Maven scans for Maven plugins.</para>

      <example id="ex-plugin-groups">
        <title>Customizing the Plugin Groups in Maven Settings</title>

        <programlisting language="xml">&lt;settings&gt;
  ...
  &lt;pluginGroups&gt;
    &lt;pluginGroup&gt;org.sonatype.mavenbook.plugins&lt;/pluginGroup&gt;
  &lt;/pluginGroups&gt;
&lt;/settings&gt;</programlisting>
      </example>

      <para>You can now run <command>mvn first:echo</command> from any
      directory and see that Maven will properly resolve the goal prefix to
      the appropriate plugin identifiers. This worked because our project
      adhered to a naming convention for Maven plugins. If your plugin project
      has an <varname>artifactId</varname> which follows the pattern
      <varname>maven-first-plugin</varname> or
      <varname>first-maven-plugin</varname>. Maven will automatically assign a
      plugin goal prefix of <varname>first</varname> to your plugin. In other
      words, when the Maven Plugin Plugin is generating the Plugin descriptor
      for your plugin and you have not explicitly set the
      <varname>goalPrefix</varname> in your project, the
      <varname>plugin:descriptor</varname> goal will extract the prefix from
      your plugin's <varname>artifactId</varname> when it matches the
      following patterns:</para>

      <itemizedlist>
        <listitem>
          <para><varname>\${prefix}-maven-plugin</varname>, OR</para>
        </listitem>

        <listitem>
          <para><varname>maven-\${prefix}-plugin</varname></para>
        </listitem>
      </itemizedlist>

      <para>If you would like to set an explicit plugin prefix, you'll need to
      configure the Maven Plugin Plugin. The Maven Plugin Plugin is a plugin
      that is responsible for building the Plugin descriptor and performing
      plugin specific tasks during the package and load phases. The Maven
      Plugin Plugin can be configured just like any other plugin in the build
      element. To set the plugin prefix for your plugin, add the following
      build element to the <varname>first-maven-plugin</varname> project's
      <filename>pom.xml</filename>.</para>

      <example id="ex-plugin-prefix">
        <title>Configuring a Plugin Prefix</title>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;first-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;maven-plugin&lt;/packaging&gt;
  &lt;name&gt;first-maven-plugin Maven Mojo&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-plugin-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.3&lt;/version&gt;
        &lt;configuration&gt;
          &lt;goalPrefix&gt;blah&lt;/goalPrefix&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;
      &lt;artifactId&gt;maven-plugin-api&lt;/artifactId&gt;
      &lt;version&gt;2.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para><xref linkend="ex-plugin-prefix" /> sets the plugin prefix to
      <varname>blah</varname>. If you've added the
      <varname>org.sonatype.mavenbook.plugins</varname> to the
      <sgmltag>pluginGroups</sgmltag> in your
      <filename>~/.m2/settings.xml</filename>, you should be able to execute
      the <classname>EchoMojo</classname> by running <command>mvn
      echo:blah</command> from any directory.</para>
    </section>

    <section id="writing-plugins-sect-logging">
      <title>Logging from a Plugin</title>

      <para>Maven takes care of connecting your Mojo to a logging provider by
      calling <methodname>setLog()</methodname> prior to the execution of your
      Mojo. It supplies an implementation of
      <classname>org.apache.maven.monitor.logging.Log</classname>. This class
      exposes methods that you can use to communicate information back to the
      user. This <classname>Log</classname> class provides multiple levels of
      logging similar to that <acronym>API</acronym> provided by <ulink
      url="http://logging.apache.org/">Log4J</ulink>. Those levels are
      captured by a series of methods available for each level: debug, info,
      error and warn. To save trees, we've only listed the methods for a
      single logging level: debug.</para>

      <variablelist>
        <varlistentry>
          <term><methodname>void debug( CharSequence message
          )</methodname></term>

          <listitem>
            <para>Prints a message to the debug logging level.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>void debug( CharSequence message, Throwable t
          )</methodname></term>

          <listitem>
            <para>Prints a message to the debug logging level which includes
            the stack trace from the <classname>Throwable</classname> (either
            <classname>Exception</classname> or
            <classname>Error</classname>)</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>void debug( Throwable t )</methodname></term>

          <listitem>
            <para>Prints out the stack trace of the
            <classname>Throwable</classname> (either
            <classname>Exception</classname> or
            <classname>Error</classname>)</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Each of the four levels exposes the same three methods. The four
      logging levels serve different purposes. The debug level exists for
      debugging purposes and for people who want to see a very detailed
      picture of the execution of a Mojo. You should use the debug logging
      level to provide as much detail on the execution of a Mojo, but you
      should never assume that a user is going to see the debug level. The
      info level is for general informational messages that should be printed
      as a normal course of operation. If you were building a plugin that
      compiled code using a compiler, you might want to print the output of
      the compiler to the screen.</para>

      <para>The warn logging level is used for messages about unexpected
      events and errors that your Mojo can cope with. If you were trying to
      run a plugin that compiled Ruby source code, and there was no Ruby
      source code available, you might want to just print a warning message
      and move on. Warnings are not fatal, but errors are usually
      build-stopping conditions. For the completely unexpected error
      condition, there is the error logging level. You would use error if you
      couldn't continue executing a Mojo. If you were writing a Mojo to
      compile some Java code and the compiler wasn't available, you'd print a
      message to the error level and possibly pass along an Exception that
      Maven could print out for the user. You should assume that a user is
      going to see most of the messages in info and all of the messages in
      error.</para>
    </section>

    <section id="writing-plugins-sect-class-annotations">
      <title>Mojo Class Annotations</title>

      <para>In <varname>first-maven-plugin</varname>, you didn't write the
      plugin descriptor yourself, you relied on Maven to generate the plugin
      descriptor from your source code. The descriptor was generated using
      your plugin project's <acronym>POM</acronym> information and a set of
      annotations on your <classname>EchoMojo</classname> class.
      <classname>EchoMojo</classname> only specifies the
      <classname>@goal</classname> annotation, here is a list of other
      annotations you can place on your <classname>Mojo</classname>
      implementation.</para>

      <para><variablelist>
          <varlistentry>
            <term>@goal &lt;goalName&gt;</term>

            <listitem>
              <para>This is the only required annotation which gives a name to
              this goal unique to this plugin.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@requiresDependencyResolution &lt;requireScope&gt;</term>

            <listitem>
              <para>Flags this mojo as requiring the dependencies in the
              specified scope (or an implied scope) to be resolved before it
              can execute. Supports compile, runtime, and test. If this
              annotation had a value of <varname>test</varname>, it would tell
              Maven that the Mojo cannot be executed until the dependencies in
              the test scope had been resolved.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@requiresProject (true|false)</term>

            <listitem>
              <para>Marks that this goal must be run inside of a project,
              default is <literal>true</literal>. This is opposed to plugins
              like archetypes, which do not.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@requiresReports (true|false)</term>

            <listitem>
              <para>If you were creating a plugin that relies on the presence
              of reports, you would need to set
              <varname>requiresReports</varname> to <varname>true</varname>.
              The default value of this annotation is false.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@aggregator (true|false)</term>

            <listitem>
              <para>A Mojo with <varname>aggregator</varname> set to
              <varname>true</varname> is supposed to only run once during the
              execution of Maven, it was created to give plugin developers the
              ability to summarize the output of a series of builds; for
              example, to create a plugin that summarizes a report across all
              projects included in a build. A goal with
              <varname>aggregator</varname> set to <varname>true</varname>
              should only be run against the top-level project in a Maven
              build. The default value of <varname>aggregator</varname> is
              <varname>false</varname>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@requiresOnline (true|false)</term>

            <listitem>
              <para>When set to <varname>true</varname>, Maven must not be
              running in offline mode when this goal is executed. Maven will
              throw an error if one attempts to execute this goal offline.
              Default: <varname>false</varname>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@requiresDirectInvocation</term>

            <listitem>
              <para>When set to <varname>true</varname>, the goal can only be
              executed if it is explicitly executed from the command-line by
              the user. Maven will throw an error if someone tries to bind
              this goal to a lifecycle phase. The default for this annotation
              is <varname>false</varname>.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@phase &lt;phaseName&gt;</term>

            <listitem>
              <para>This annotation specifies the default phase for this goal.
              If you add an execution for this goal to a
              <filename>pom.xml</filename> and do not specify the phase, Maven
              will bind the goal to the phase specified in this annotation by
              default.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@execute [goal=goalName|phase=phaseName
            [lifecycle=lifecycleId]]</term>

            <listitem>
              <para>This annotation can be used in a number of ways. If a
              phase is supplied, Maven will execute a parallel lifecycle
              ending in the specified phase. The results of this separate
              execution will be made available in the Maven property
              <varname>\${executedProperty}</varname>.</para>

              <para>The second way of using this annotation is to specify an
              explicit goal using the <varname>prefix:goal</varname> notation.
              When you specify just a goal, Maven will execute this goal in a
              parallel environment that will not affect the current Maven
              build.</para>

              <para>The third way of using this annotation would be to specify
              a phase in an alternate lifecycle using the identifier of a
              lifecycle.</para>

              <programlisting language="java">@execute phase="package" lifecycle="zip"
@execute phase="compile"
@execute goal="zip:zip"</programlisting>
            </listitem>
          </varlistentry>
        </variablelist></para>

      <para>If you look at the source for <classname>EchoMojo</classname>,
      you'll notice that Maven is not using the standard annotations available
      in Java 5. Instead, it is using <ulink
      url="http://commons.apache.org/attributes/">Commons Attributes</ulink>.
      Commons Attributes provided a way for Java programmers to use
      annotations before annotations were a part of the Java language
      specification. Why doesn't Maven use Java 5 annotations? Maven doesn't
      use Java 5 annotations because it is designed to target pre-Java 5
      <acronym>JVM</acronym>s. Because Maven has to support older versions of
      Java, it cannot use any of the newer features available in Java
      5.</para>
    </section>

    <section id="writing-plugins-sect-failure">
      <title>When a Mojo Fails</title>

      <para>The <methodname>execute()</methodname> method in Mojo throws two
      exceptions <classname>MojoExecutionException</classname> and
      <classname>MojoFailureException</classname>. The difference between
      these two exception is both subtle and important, and it relates to what
      happens when a goal execution "fails". A
      <classname>MojoExecutionException</classname> is a fatal exception,
      something unrecoverable happened. You would throw a
      <classname>MojoExecutionException</classname> if something happens that
      warrants a complete stop in a build; you re trying to write to disk, but
      there is no space left, or you were trying to publish to a remote
      repository, but you can't connect to it. Throw a
      <classname>MojoExecutionException</classname> if there is no chance of a
      build continuing; something terrible has happened and you want the build
      to stop and the user to see a "BUILD ERROR" message.</para>

      <para>A <classname>MojoFailureException</classname> is something less
      catastrophic, a goal can fail, but it might not be the end of the world
      for your Maven build. A unit test can fail, or a <acronym>MD5</acronym>
      checksum can fail; both of these are potential problems, but you don't
      want to return an exception that is going to kill the entire build. In
      this situation you would throw a
      <classname>MojoFailureException</classname>. Maven provides for
      different "resiliency" settings when it comes to project failure. Which
      are described below.</para>

      <para>When you run a Maven build, it could involve a series of projects
      each of which can succeed or fail. You have the option of running Maven
      in three failure modes:</para>

      <variablelist>
        <varlistentry>
          <term>mvn -ff</term>

          <listitem>
            <para>Fail-fast mode: Maven will fail (stop) at the first build
            failure.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>mvn -fae</term>

          <listitem>
            <para>Fail-at-end: Maven will fail at the end of the build. If a
            project in the Maven reactor fails, Maven will continue to build
            the rest of the builds and report a failure at the end of the
            build.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>mvn -fn</term>

          <listitem>
            <para>Fail never: Maven won't stop for a failure and it won't
            report a failure.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>You might want to ignore failure if you are running a continuous
      integration build and you want to attempt a build regardless of the
      success of failure of an individual project build. As a plugin
      developer, you'll have to make a call as to whether a particular failure
      condition is a <classname>MojoExecutionException</classname> or a
      <classname>MojoFailureExeception</classname>.</para>
    </section>
  </section>

  <section id="writing-plugins-sect-mojo-params">
    <title>Mojo Parameters</title>

    <para>Just as important as the <methodname>execute()</methodname> method
    and the Mojo annotations, a Mojo is configured via parameters. This
    section deals with some configuration and topics surrounding Mojo
    parameters.</para>

    <section id="writing-plugins-sect-param-values">
      <title>Supplying Values for Mojo Parameters</title>

      <para>In EchoMojo we declared the message parameter with the following
      annotations:</para>

      <programlisting language="java">/**
 * Any Object to print out.
 * @parameter
 *       expression="\${echo.message}"
 *       default-value="Hello Maven World"
 */
private Object message;
</programlisting>

      <para>The default expression for this parameter is
      <varname>\${echo.message}</varname>, this means that Maven will try to
      use the value of the <varname>echo.message</varname> property to set the
      value for message. If the value of the <varname>echo.message</varname>
      property is null, the default-value attribute of the
      <classname>@parameter</classname> annotation will be used instead.
      Instead of using the <varname>echo.message</varname> property, we can
      configure a value for the message parameter of the EchoMojo directly in
      a project's <acronym>POM</acronym>.</para>

      <para>There are a few ways to populate the message parameter in the
      <classname>EchoMojo</classname>. First we can pass in a value from the
      command-line like this (assuming that you've added
      <varname>org.sonatype.mavenbook.plugins</varname> to your
      <sgmltag>pluginGroups</sgmltag>):</para>

      <screen>$ mvn first:echo -Decho.message="Hello Everybody"</screen>

      <para>We could also specify the value of this message parameter, by
      setting a property in our <acronym>POM</acronym> or in our
      <filename>settings.xml</filename>.</para>

      <programlisting language="xml">&lt;project&gt;
  ...
  &lt;properties&gt;
    &lt;echo.message&gt;Hello Everybody&lt;/echo.message&gt;
  &lt;/properties&gt;
&lt;/project&gt;
</programlisting>

      <para>This parameter could also be configured directly as a
      configuration value for the plugin. If we wanted to customize the
      message parameter directly, we could use the following build
      configuration. The following configuration bypasses the echo.message
      property and populates the Mojo parameter in plugin
      configuration.</para>

      <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.sonatype.mavenbook.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;first-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;configuration&gt;
          &lt;message&gt;Hello Everybody!&lt;/message&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;</programlisting>

      <para>If we wanted to run the <classname>EchoMojo</classname> twice at
      difference phases in a lifecycle, and we wanted to customize the message
      parameter for each execution separately, we could configure the
      parameter value at the execution level in a <acronym>POM</acronym> like
      this:</para>

      <programlisting language="xml">&lt;build&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.sonatype.mavenbook.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;first-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;first-execution&lt;/id&gt;
            &lt;phase&gt;generate-resources&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;echo&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;message&gt;The Eagle has Landed!&lt;/message&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
          &lt;execution&gt;
            &lt;id&gt;second-execution&lt;/id&gt;
            &lt;phase&gt;validate&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;echo&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;message&gt;\${project.version}&lt;/message&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/build&gt;</programlisting>

      <para>While this last configuration example seems very verbose, it
      illustrates the flexibility of Maven. In the previous configuration
      example, you've bound the <classname>EchoMojo</classname> to both the
      <varname>validate</varname> and <varname>generate-resources</varname>
      phases in the default Maven lifecycle. The first execution is bound to
      <varname>generate-resources</varname>, it supplies a string value to the
      message parameter of "The Eagle has Landed!". The second execution is
      bound to the <varname>validate</varname> phase, it supplies a property
      reference to <varname>\${project.version}</varname>. When you run
      <command>mvn install</command> for his project, you'll see that the
      <varname>first:echo</varname> goal executes twice and prints out two
      different messages.</para>
    </section>

    <section id="writing-plugins-sect-multival-params">
      <title>Multi-valued Mojo Parameters</title>

      <para>Plugins can have parameters which accept more than one value. Take
      a look at the <classname>ZipMojo</classname> shown in <xref
      linkend="ex-plugin-multivalue" />. Both the <varname>includes</varname>
      and <varname>excludes</varname> parameters are multivalued
      <classname>String</classname> arrays which specify the inclusion and
      exclusion patterns for a component that creates a <acronym>ZIP</acronym>
      file.</para>

      <example id="ex-plugin-multivalue">
        <title>A Plugin with Multi-valued Parameters</title>

        <programlisting language="java">package org.sonatype.mavenbook.plugins

/**
 * Zips up the output directory.
 * @goal zip
 * @phase package
 */
public class ZipMojo extends AbstractMojo
{
    /**
     * The Zip archiver.
     * @parameter \
         expression="\${component.org.codehaus.plexus.archiver.Archiver#zip}"
     */
    private ZipArchiver zipArchiver;

    /**
     * Directory containing the build files.
     * @parameter expression="\${project.build.directory}"
     */
    private File buildDirectory;

    /**
     * Base directory of the project.
     * @parameter expression="\${basedir}"
     */
    private File baseDirectory;

    /**
     * A set of file patterns to include in the zip.
     * @parameter alias="includes"
     */
    private String[] mIncludes;

    /**
     * A set of file patterns to exclude from the zip.
     * @parameter alias="excludes"
     */
    private String[] mExcludes;

    public void setExcludes( String[] excludes ) { mExcludes = excludes; }

    public void setIncludes( String[] includes ) { mIncludes = includes; }

    public void execute()
        throws MojoExecutionException
    {
        try {
            zipArchiver.addDirectory( buildDirectory, includes, excludes );
            zipArchiver.setDestFile( new File( baseDirectory, "output.zip" ) );
            zipArchiver.createArchive();
        } catch( Exception e ) {
            throw new MojoExecutionException( "Could not zip", e );
        }
    }
}
</programlisting>

        <para>To configure a multi-valued Mojo parameter, you use a series of
        elements for each value. If the name of the multi-valued parameter is
        <varname>includes</varname>, you would use an element
        <sgmltag>includes</sgmltag> with child elements
        <sgmltag>include</sgmltag>. If the multi-valued parameter is
        <varname>excludes</varname>, you would use an element
        <sgmltag>excludes</sgmltag> with child elements
        <sgmltag>exclude</sgmltag>. To configure the
        <classname>ZipMojo</classname> to ignore all files ending in
        <varname>.txt</varname> and all files ending in a tilde, you would use
        the following plugin configuration.</para>
      </example>

      <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.sonatype.mavenbook.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;zip-maven-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;excludes&gt;
            &lt;exclude&gt;**/*.txt&lt;/exclude&gt;
            &lt;exclude&gt;**/*~&lt;/exclude&gt;
          &lt;/excludes&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</programlisting>
    </section>

    <section id="writing-plugins-sect-depend-plexus">
      <title>Depending on Plexus Components</title>

      <para>A Mojo is a component managed by an <acronym>IoC</acronym>
      container called Plexus. A Mojo can depend on other components managed
      by Plexus by declaring a Mojo parameter and using the
      <classname>@parameter</classname> or the
      <classname>@component</classname> annotation. <xref
      linkend="ex-plugin-multivalue" /> shows a <classname>ZipMojo</classname>
      which depends on a Plexus component using the
      <classname>@parameter</classname> annotation, this dependency could be
      declared using the <classname>@component</classname> annotation.</para>

      <example>
        <title>Depending on a Plexus Component</title>

        <programlisting language="java">/**
 * The Zip archiver.
 * @component role="org.codehaus.plexus.archiver.Archiver" roleHint="zip"
 */
private ZipArchiver zipArchiver;</programlisting>
      </example>

      <para>When Maven instantiates this Mojo, it will then attempt to
      retrieve the Plexus component with the specified role and role hint. In
      this example, the Mojo will be related to a ZipArchiver component which
      will allow the <classname>ZipMojo</classname> to create a
      <acronym>ZIP</acronym> file.</para>

      <!--TODO: OK, we need more here.  How do I get my hands on components?  How to a bundle components?-->
    </section>

    <section id="writing-plugins-sect-param-annot">
      <title>Mojo Parameter Annotations</title>

      <para>Unless you insist on writing your Plugin descriptors by hand,
      you'll never have to write that <acronym>XML</acronym>. Instead, the
      Maven Plugin Plugin has a <varname>plugin:descriptor</varname> goal
      bound to the generate-resources phase. This goal generates the plugin
      descriptor from annotations on your Mojo. To configure a Mojo parameter,
      you should use the following annotations on either the private member
      variables for each of your Mojo's parameters. You can also use these
      annotations on public setter methods, but the most common convention for
      Maven plugins is to annotate private member variables directly.</para>

      <variablelist>
        <varlistentry>
          <term>@parameter [alias="someAlias"]
          [expression="\${someExpression}"] [default-value="value"]</term>

          <listitem>
            <para>Marks a private field (or a setter method) as a parameter.
            The <varname>alias</varname> provides the name of the parameter.
            If <varname>alias</varname> is omitted, Maven will use the name of
            the variable as the parameter name. The
            <varname>expression</varname> is an expression that Maven will
            evaluate to obtain a value. Usually the expression is a property
            reference like <varname>\${echo.message}</varname>.
            <varname>default-value</varname> is the value that this Mojo will
            use if no value can be derived from the expression or if a value
            was not explicitly supplied via plugin configuration in a
            <acronym>POM</acronym>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@required</term>

          <listitem>
            <para>If this annotation is present, a valid value for this
            parameter is required prior to Mojo execution. If Maven tries to
            execute this Mojo and the parameter has a null value, Maven will
            throw and error when it tries to execute this goal.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@readonly</term>

          <listitem>
            <para>If this annotation is present, the user cannot directly
            configuration this parameter in the <acronym>POM</acronym>. You
            would use this annotation with the expression attribute of the
            parameter annotation. For example, if you wanted to make sure that
            a particular parameter always had the value of the
            <varname>finalName</varname> <acronym>POM</acronym> property, you
            would list an expression of <varname>\${build.finalName}</varname>
            and then add the <classname>@readOnly</classname> annotation. If
            this were the case, the user could only change the value of this
            parameter by changing the value of <varname>finalName</varname> in
            the <acronym>POM</acronym>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@component</term>

          <listitem>
            <para>Tells Maven to populate a field with a Plexus Component. A
            valid value for the <classname>@component</classname> annotation
            would be:</para>

            <programlisting language="java">@component role="org.codehaus.plexus.archiver.Archiver" roleHint="zip"
</programlisting>

            <para>This would have the effect of retrieving the
            <classname>ZipArchiver</classname> from Plexus. The
            <classname>ZipArchiver</classname> is the Archiver which
            corresponds to the role hint <varname>zip</varname>. Instead of
            component, you could also use the @parameter annotation with an
            expression attribute of:</para>

            <programlisting language="java">@parameter expression="\${component.org.codehaus.plexus.archiver.Archiver#zip}"
</programlisting>

            <para>While the two annotations are effectively the same, the
            <classname>@component</classname> annotation is the preferred way
            to configure dependencies on Plexus components.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@deprecated</term>

          <listitem>
            <para>The parameter will be deprecated. Users can continue
            configuring this parameter, but a warning message will be
            displayed.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section id="writing-plugins-sect-plugins-lifecycle">
    <title>Plugins and the Maven Lifecycle</title>

    <para>In the <xref linkend="lifecycle" /> chapter, you learned that
    lifecycles can be customized by packaging types. A plugin can both
    introduce a new packaging type and customize the lifecycle. In this
    section, you are going to learn how you can customize the lifecycle from a
    custom Maven plugin. You are also some to see how you can tell a Mojo to
    execute a parallel lifecycle.</para>

    <section id="writing-plugins-sect-execute-parallel-lifecycle">
      <title>Executing a Parallel Lifecycle</title>

      <para>Let's assume you write some goal that depends on the output from a
      previous build. Maybe the <classname>ZipMojo</classname> goal can only
      run if there is output to include in an archive. You can specify
      something like a prerequisite goal by using the
      <classname>@execute</classname> annotation on a Mojo class. This
      annotation will cause Maven to spawn a parallel build and execute a goal
      or a lifecycle in a parallel instance of Maven that isn't going to
      affect the current build. Maybe you wrote some Mojo that you can to run
      once a day that runs <command>mvn install</command> and then packages up
      all of the output in some sort of customized distribution format. Your
      Mojo descriptor could tell Maven that before you execute your
      <classname>CustomMojo</classname>, you'd like it to execute the default
      lifecycle up to the install phase and then expose the results of that
      project to your Mojo as the property
      <varname>\${executedProject}</varname>. You could then reference
      properties in that project to before some sort of post
      processing.</para>

      <para>Another possibility is that you have a goal that does something
      completely unrelated to the default lifecycle. Let's consider something
      completely unexpected, maybe you have a goal that turns a
      <acronym>WAV</acronym> file into an <acronym>MP3</acronym> using
      something like <acronym>LAME</acronym>, but before you do that, you want
      to step through a lifecycle that turns a <acronym>MIDI</acronym> file to
      a <acronym>WAV</acronym>. (You can use Maven for anything, this isn't
      that "far out".) You've created a "midi-sound" lifecycle, and you want
      to include the output of the <varname>midi-sound</varname> lifecycle's
      <varname>install</varname> phase in your web application project which
      has a <varname>war</varname> packaging type. Since your project is
      running in the <varname>war</varname> packaging lifecycle, you'll need
      to have goal that effectively forks off an isolated build and runs
      through the <varname>midi-source</varname> lifecycle. You would do this
      by annotating your mojo with <varname>@execute lifecycle="midi-source"
      phase="install"</varname>.</para>

      <variablelist>
        <varlistentry>
          <term>@execute goal="&lt;goal&gt;"</term>

          <listitem>
            <para>This will execute the given goal before execution of this
            one. The goal name is specified using the
            <varname>prefix:goal</varname> notation.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@execute phase="&lt;phase&gt;"</term>

          <listitem>
            <para>This will fork an alternate build lifecycle up to the
            specified phase before continuing to execute the current one. If
            no lifecycle is specified, Maven will use the lifecycle of the
            current build.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@execute lifecycle="&lt;lifecycle&gt;"
          phase="&lt;phase&gt;"</term>

          <listitem>
            <para>This will execute the given alternate lifecycle. A custom
            lifecycle can be defined in
            <filename>META-INF/maven/lifecycle.xml</filename>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section id="writing-plugins-sect-custom-lifecycle">
      <title>Creating a Custom Lifecycle</title>

      <para>A custom lifecycle must be packaged in the plugin under the
      <filename>META-INF/maven/lifecycle.xml</filename> file. You can include
      a lifecycle under <filename>src/main/resources</filename> in
      <filename>META-INF/maven/lifecycle.xml</filename>. The following
      <filename>lifecycle.xml</filename> declares a lifecycle named
      <varname>zipcycle</varname> that contains only the
      <varname>zip</varname> goal in a <varname>package</varname>
      phase.</para>

      <para><example>
          <title>Define a Custom Lifecycle in lifecycle.xml</title>

          <programlisting language="xml">&lt;lifecycles&gt;
  &lt;lifecycle&gt;
    &lt;id&gt;zipcycle&lt;/id&gt;
    &lt;phases&gt;
      &lt;phase&gt;
        &lt;id&gt;package&lt;/id&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;goals&gt;
              &lt;goal&gt;zip&lt;/goal&gt;
            &lt;/goals&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/phase&gt;
    &lt;/phases&gt;
  &lt;/lifecycle&gt;
&lt;/lifecycles&gt;
</programlisting>
        </example></para>

      <para>If you wanted to execute the <varname>zipcycle</varname> phase
      within another build, you could then create a
      <classname>ZipForkMojo</classname> which uses the
      <classname>@execute</classname> annotation to tell Maven to step through
      the <varname>zipcycle</varname> phase to package when the
      <classname>ZipForkMojo</classname> is executed.</para>

      <para><example>
          <title>Forking a Customer Lifecycle from a Mojo</title>

          <programlisting language="java">/**
 * Forks a zip lifecycle.
 * @goal zip-fork
 * @execute lifecycle="zipcycle" phase="package"
 */
public class ZipForkMojo extends AbstractMojo
{
  public void execute()
    throws MojoExecutionException
  {
    getLog().info( "doing nothing here" );
  }
}
</programlisting>
        </example></para>

      <para>Running the <classname>ZipForkMojo</classname> will fork the
      lifecycle. If you've configured your plugin to execute with the goal
      prefix <varname>zip</varname>, running <varname>zip-fork</varname>
      should produce something similar to the following output.</para>

      <screen>$ mvn zip:zip-fork
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'zip'.
[INFO] ----------------------------------------------------------------------
[INFO] Building Maven Zip Forked Lifecycle Test
[INFO]    task-segment: [zip:zip-fork]
[INFO] ----------------------------------------------------------------------
[INFO] Preparing zip:zip-fork
[INFO] [site:attach-descriptor]
[INFO] [zip:zip]
[INFO] Building zip: \
   ~/maven-zip-plugin/src/projects/zip-lifecycle-test/target/output.zip
[INFO] [zip:zip-fork]
[INFO] doing nothing here
[INFO] ---------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ---------------------------------------------------------------------
[INFO] Total time: 1 second
[INFO] Finished at: Sun Apr 29 16:10:06 CDT 2007
[INFO] Final Memory: 3M/7M
[INFO] ---------------------------------------------------------------------
</screen>

      <para>Calling <varname>zip-fork</varname> spawned another lifecycle,
      Maven executed the <varname>zipcycle</varname> lifecycle then it printed
      out the message from <classname>ZipFormMojo</classname>'s execute
      method.</para>
    </section>

    <section id="writing-plugins-sect-override-default-lifecycle">
      <title>Overriding the Default Lifecycle</title>

      <para>Once you've created your own lifecycle and spawned it from a Mojo.
      The next question you might have is how do you override the default
      lifecycle. How do you create custom lifecycles and attach them to
      projects? In <xref linkend="lifecycle" />, we saw that the packaging of
      a project defines the lifecycle of a project. There's something
      different about almost every packaging type; <varname>war</varname>
      attached different goals to package, custom lifecycles like
      <varname>swf</varname> from the Israfil Flex 3 plugin attach different
      goals to the compile phase. When you create a custom lifecycle, you can
      attach that lifecycle to a packaging type by supplying some Plexus
      configuration in your plugin's archive.</para>

      <para>To define a new lifecycle for a new packaging type, you'll need to
      configure a <classname>LifecycleMapping</classname> component in Plexus.
      In your plugin project, create a
      <filename>META-INF/plexus/components.xml</filename> under
      src/main/resources. In components.xml add the content from <xref
      linkend="ex-override-lifecycle" />. Set the name of the packaging type
      under <varname>role-hint</varname>, and the set of phases containing the
      coordinates of the goals to bind (omit the version). Multiple goals can
      be associated with a phase using a comma delimited list.</para>

      <para><example id="ex-override-lifecycle">
          <title>Overriding the Default Lifecycle</title>

          <programlisting language="xml">&lt;component-set&gt;
  &lt;components&gt;
    &lt;component&gt;
      &lt;role&gt;org.apache.maven.lifecycle.mapping.LifecycleMapping&lt;/role&gt;
      &lt;role-hint&gt;zip&lt;/role-hint&gt;
      &lt;implementation&gt;
        org.apache.maven.lifecycle.mapping.DefaultLifecycleMapping
      &lt;/implementation&gt;
      &lt;configuration&gt;
        &lt;phases&gt;
          &lt;process-resources&gt;
            org.apache.maven.plugins:maven-resources-plugin:resources
          &lt;/process-resources&gt;
          &lt;compile&gt;
            org.apache.maven.plugins:maven-compiler-plugin:compile
          &lt;/compile&gt;
          &lt;package&gt;org.sonatype.mavenbook.plugins:maven-zip-plugin:zip&lt;/package&gt;
        &lt;/phases&gt;
      &lt;/configuration&gt;
    &lt;/component&gt;
  &lt;/components&gt;
&lt;/component-set&gt;
</programlisting>
        </example></para>

      <para>If you create a plugin which defines a new packaging type and a
      customized lifecycle, Maven won't know anything about it until you add the
      plugin to your project's <acronym>POM</acronym> and set the extensions
      element to true. Once you do this, Maven will scan your plugin for more
      than just Mojos to execute, it will look for the
      <filename>components.xml</filename> under
      <filename>META-INF/plexus</filename>, and it will make the packaging
      type available to your project.</para>

      <para><example>
          <title>Configuring a Plugin as an Extension</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    ...
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;com.training.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-zip-plugin&lt;/artifactId&gt;
        &lt;extensions&gt;true&lt;/extensions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>Once you add the plugin with the extensions element set to true,
      you can use the custom packaging type and your project will be able to
      execute the custom lifecycle associated with that packaging type.</para>
    </section>
  </section>
</chapter>
