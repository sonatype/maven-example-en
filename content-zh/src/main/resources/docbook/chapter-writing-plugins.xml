<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="writing-plugins">
  <title>编写插件</title>

  <section>
    <title>简介</title>

    <para>虽然本章介绍的是高级话题。讲述编写Maven插件，但不要被吓到。对于该工具的所有理论和复杂性来说，基本的概念还是比较容易理解的，而编写插件的方法也十分易懂。在你阅读本章之后，你会能更好的掌握编写Maven插件所涉及的内容。</para>
  </section>

  <section>
    <title>Maven编程</title>

    <para>本书的绝大部分都在讲述使用Maven，在这本关于Maven的书中，你还没看到太多关于Maven自定义的样例代码。事实上，到目前为止这样的代码还没有。这本是设计的目的，99%的Maven用户将从来不需要编写自定义插件来定制Maven；有大量的可配置的插件可用，除非你有特别的单独需求，你没有理由自己去编写一个新的插件。而这那一小部分编写自定义插件的人中，也只有更少的人需要去查看Maven的源码以自定义Maven核心组件。如果你确实需要自定义Maven的行为，那么你可以编写一个插件。修改核心Maven代码与修改操作系统的TCP/IP堆栈一样，远远超出了大部分开发人员的范围，这对于大部分Maven用户来说过于抽象。</para>

    <para>另一方面，如果你想要开始编写自定义插件，你就需要学习一些Maven的内部原理：它如何管理软件组件？什么是一个插件？我如何能够自定义生命周期？本节将解答其中的一些问题，并介绍一些Maven设计核心的概念。学习如何编写Maven插件同时也是学习定制Maven本身一种很好的方式。如果你想知道如何开始理解Maven背后的代码，那么你已经找到了正确的出发点。</para>

    <section>
      <title>什么是反转控制？</title>

      <para>Maven的心脏是一个名为Plexus的反转控制（IoC）框架。它做什么呢？这是一个用来管理及关联组件的系统。虽然有一篇Martin
      Fowler编写的关于Ioc的权威论文，但这个概念和术语在过去的一些年中已经被大量的重载，因此找出一个关于此概念的良好定义已经变得非常困难，很多定义都是自我指认的（或者对于上述论文的简单引用）。这里我们将通过一个比喻来简要介绍反转控制和依赖注入，而不是简单的援引维基百科。</para>

      <para>假设你有一系列的组件需要装配在一起。当你考虑组件的时候，将其想象成立体声音响组件而非软件组件。想象一下有一些音响组件接通了一个Playstation
      3和一个机顶盒，后者又需要连接一个苹果电视盒以及一个50英寸的平板液晶电视。你从电子产品商店将所有这些东西带回家，并购买了一些电缆准备用来连接这些电器。你将所有组件拆开，将其放到正确的位置，然后开始连接同轴电缆，数字输入设备，立体声控制设备，以及网线等等。从你的家庭娱乐中心后退一步，然后打开电视机，你已经完成了依赖注入，你刚才正处在一个反转控制容器中。</para>

      <para>那么，你到底需要做什么？你的Playstation 3和一个Java Bean都提供接口。Playstation
      3有两个输入：电源和网络，以及一个电视输出。你的Java
      Bean有三个属性：power，network，和tvOutput。当你打开Playstation
      3盒子的时候，它并不会提供关于连接所有不同种类电视的详细图片和指令，当你查看你的Java
      Bean的时候，它也只是提供了一组属性，而不是创建和管理整个系统组件的显式的方法。在一个如Plexus的IoC容器中，你负责通过简单的提供输入输出接口声明组件之间的关系。你不需要初始化对象，Plexus会帮你完成；你的应用程序的代码不用去管理组件的状态，Plexus负责。虽然这听起来非常俗套，不过这里还是要说，当你启动Maven的时候，实际上是启动Plexus来管理一个带有很多相互关联组件的系统，就像你的家庭影音系统一样。</para>

      <para>那么，使用Ioc容器的优点是什么呢？购买离散的音响组件的优点是什么？如果一个组件坏了，你可以放一个Playstation
      3的替代品，而不用花20,000美元去重新购买整个系统。如果你对电视机不满意，你可以在不影响CD播放器的情况下将电视换掉。对你来说最重要的是，你的音响组件现在花费更低，但功能更强，且更稳定，因为制造商现在根据一组通用的输入输出来制造组件，他们能够更加的关注组件本身。反转控制和依赖注入提倡分解以及标准的形成。软件产业喜欢自己给新的想法命名，但依赖注入和反转控制实际上只是对于分解以可交换体系的新词。如果你真的想要好好了解DI和IoC，你可以学习一下Model
      T，Cotton Gin，以及19世纪末期形成的一个铁路系统标准。</para>
    </section>

    <section>
      <title>Plexus简介</title>

      <para>用Java实现的<acronym>IoC</acronym>容器中，最重要的一个功能是称作依赖注入的机制。<acronym>IoC</acronym>的基本想法是将对象的创建和管理从代码中剥离，并将控制放到<acronym>IoC</acronym>框架手中。在一个面向接口编程的应用程序中使用依赖注入，你创建的组件可以不与任何特定的接口实现绑定。你的程序也针对接口编程并通过配置Plexus来将正确的实现连接到正确的组件。虽然你的代码都是与接口打交道，但你仍然可以通过一个定义组件的<acronym>XML</acronym>文件来获得类和组件相互依赖的信息。换句话说，你可以编写独立的组件，然后你可以通过一个<acronym>XML</acronym>文件来定义组件应当如何被装配在一起。在Plexus的情形中，定义系统组件的<acronym>XML</acronym>文档位于<filename>META-INF/plexus/components.xml</filename>。</para>

      <para>在一个Java
      <acronym>IoC</acronym>容器中，有很多中方法来将依赖值注入到一个组件对象中：构造器，set方法，或者字段注入。虽然Plexus提供全部这三种依赖注入技术，Maven使用其中的两种：字段注入和set方法注入。</para>

      <variablelist>
        <varlistentry>
          <term>构造器注入</term>

          <listitem>
            <para>构造器注入是指当对象实例被创建的时候，通过对象的构造方法将填入对象的值。例如，如果你有类对象<classname>Person</classname>，其构造方法是<methodname>Person(String
            name, Job
            job)</methodname>，你就可以通过该构造器传入<varname>name</varname>和<varname>job</varname>的值。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>set方法注入</term>

          <listitem>
            <para>set方法注入是指使用Java
            Bean属性的set方法来填入对象依赖。例如，如果你有一个带有<varname>name</varname>和<varname>job</varname>属性的<classname>Person</classname>对象，一个使用set方法注入的<acronym>IoC</acronym>容器会使用无参构造器创建一个<classname>Person</classname>的实例，之后，它会继续调用<methodname>setName()</methodname>和<methodname>setJob()</methodname>方法。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>字段注入</term>

          <listitem>
            <para>构造器和set方法注入都依赖于公共方法。而使用字段注入的时候，<acronym>IoC</acronym>容器通过直接设置对象字段的值来填入组件依赖。例如，如果你有一个带有<varname>name</varname>和<varname>job</varname>字段的<classname>Person</classname>对象，你的<acronym>IoC</acronym>容器会直接设置这两个字段来填入依赖（如：<code>person.name
            = "Thomas"; person.job = job;</code>）。</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section>
      <title>为什么使用Plexus?</title>

      <para>目前Spring是最流行的IoC容器。它影响了Java的“生态系统”，迫使如Sun
      Microsystems之类的公司让出更多的对于开源社区的控制，并通过提供一个更易插入的，面向组件的“总线”来帮助开发一些标准。但是Spring不是唯一的开源IoC容器。事实上有很多IoC容器（如<ulink
      url="http://www.picocontainer.org/">PicoContainer</ulink>）。</para>

      <para>很多年以前，当Maven被创建的时候，Spring并不是一个成熟的选项。最初的Maven提交者团队更熟悉Plexus因为正式它们发明了Plexus，因此他们决定使用Plexus做为Ioc容器。虽然它没有Spring
      Framework流行，但并不是说它的功能没那么强大。而且，事实上它是由创建Maven的同一个人发明的，这使其更适合Maven。阅读本章之后你会了解Plexus如何工作。如果你使用过一个IoC容器你会注意到Plexus和你使用的另外一个IoC容器的相似性和差异性。</para>

      <note>
        <para>Maven基于Plexus并不意味着Maven社区是“反Spring”的（我们在本书中包含了整整的一章关于Spring样例的内容，Spring项目的一部分也转移到Maven作为构建平台）。由于疑问“你们为什么不用Spring”经常出现，因此这里解释这个问题。我们知道，Spring是一个明星，我们并不拒绝它，但为人们介绍Plexus仍然是我们持续要做的工作：软件产业中，更多的选择总是好事。</para>
      </note>
    </section>

    <section>
      <title>什么是插件？</title>

      <para>一个Maven插件是包含了一个插件描述符和一个或者多个Mojo的Maven构件。一个Mojo可以被认为是Maven中的一个目标，每一个目标对应了一个Mojo。<varname>compiler:compile</varname>目标对应了Maven
      Compiler插件的<classname>CompilerMojo</classname>类，<varname>jar:jar</varname>目标对应了Maven
      Jar插件的<classname>JarMojo</classname>类。当你编写自己的插件的时候，你在一个单独的插件构件中将一组相互关联的Mojo（或者目标）归类。</para>

      <para><footnote id="foot-mojo-def">
          <para>“mojo.”美国传统英语字典，第四版。Houghton Mifflin公司，2004，Answer.com 02 Mar.
          2008. <ulink
          url="http://www.answers.com/topic/mojo-1">http://www.answers.com/topic/mojo-1</ulink></para>
        </footnote></para>

      <note>
        <para>Mojo?什么是Mojo?词mojo<footnoteref
        linkend="foot-mojo-def" />被定义为“一种神奇的魔力或咒语”，“一个护身符，通常是一个包含了一个或多个神奇物件的法兰绒小包”，以及“个人魅力；吸引力”。Maven使用术语Mojo因为这是一个对于Pojo（Plan-old
        Java Object）的玩笑。</para>
      </note>

      <para>Mojo不仅仅是Maven中的一个目标，它是一个由Plexus管理的组件，可以引用其它Plexus组件。</para>
    </section>
  </section>

  <section>
    <title>插件描述符</title>

    <para>Maven插件包含了一个告诉Maven各种Mojo和插件配置的路线图。这就是插件描述符，它位于<acronym>JAR</acronym>文件中的<filename>META-INF/maven/plugin.xml</filename>。当Maven载入一个插件的时候，它读取该<acronym>XML</acronym>文件，初始化并配置插件对象是Mojo被包含在插件中，供Maven使用。</para>

    <para>当你编写自定义Maven插件的时候，你几乎不会想到编写插件描述符。在<xref
    linkend="lifecycle" />中，绑定到<varname>maven-plugin</varname>打包类型的生命周期目标显示，<varname>plugin:descriptor</varname>目标被绑定到了<varname>generate-resources</varname>生命周期阶段。该目标根据插件源码中的标注生成一个插件描述符。本章后面，你会看到如何标注Mojo，并且你会了解这些标注最终如何成为<filename>META-INF/maven/plugin.xml</filename>文件的内容。</para>

    <para><xref linkend="ex-plugin-desc" />展示了Maven
    Zip插件的描述符。该插件简单的对输出目录进行zip压缩并归档。一般来说，你不需要编写自定义插件从Maven创建归档，你可以使用Maven
    Assembly插件，该插件能够以多种格式帮助生成分发归档。仔细阅读下面的插件描述符以了解其包含的内容：</para>

    <!--TODO: Reference Assembly Plugin Chapter-->

    <example id="ex-plugin-desc">
      <title>插件描述符</title>

      <programlisting language="xml">&lt;plugin&gt;
  &lt;description&gt;&lt;/description&gt;
  &lt;groupId&gt;com.training.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;maven-zip-plugin&lt;/artifactId&gt;
  &lt;version&gt;1-SNAPSHOT&lt;/version&gt;
  &lt;goalPrefix&gt;zip&lt;/goalPrefix&gt;
  &lt;isolatedRealm&gt;false&lt;/isolatedRealm&gt;
  &lt;inheritedByDefault&gt;true&lt;/inheritedByDefault&gt;
  &lt;mojos&gt;
    &lt;mojo&gt;
      &lt;goal&gt;zip&lt;/goal&gt;
      &lt;description&gt;Zips up the output directory.&lt;/description&gt;
      &lt;requiresDirectInvocation&gt;false&lt;/requiresDirectInvocation&gt;
      &lt;requiresProject&gt;true&lt;/requiresProject&gt;
      &lt;requiresReports&gt;false&lt;/requiresReports&gt;
      &lt;aggregator&gt;false&lt;/aggregator&gt;
      &lt;requiresOnline&gt;false&lt;/requiresOnline&gt;
      &lt;inheritedByDefault&gt;true&lt;/inheritedByDefault&gt;
      &lt;phase&gt;package&lt;/phase&gt;
      &lt;implementation&gt;com.training.plugins.ZipMojo&lt;/implementation&gt;
      &lt;language&gt;java&lt;/language&gt;
      &lt;instantiationStrategy&gt;per-lookup&lt;/instantiationStrategy&gt;
      &lt;executionStrategy&gt;once-per-session&lt;/executionStrategy&gt;
      &lt;parameters&gt;
        &lt;parameter&gt;
          &lt;name&gt;baseDirectory&lt;/name&gt;
          &lt;type&gt;java.io.File&lt;/type&gt;
          &lt;required&gt;false&lt;/required&gt;
          &lt;editable&gt;true&lt;/editable&gt;
          &lt;description&gt;Base directory of the project.&lt;/description&gt;
        &lt;/parameter&gt;
        &lt;parameter&gt;
          &lt;name&gt;buildDirectory&lt;/name&gt;
          &lt;type&gt;java.io.File&lt;/type&gt;
          &lt;required&gt;false&lt;/required&gt;
          &lt;editable&gt;true&lt;/editable&gt;
          &lt;description&gt;Directory containing the build files.&lt;/description&gt;
        &lt;/parameter&gt;
      &lt;/parameters&gt;
      &lt;configuration&gt;
        &lt;buildDirectory implementation="java.io.File"&gt;${project.build.directory}&lt;/buildDirectory&gt;
        &lt;baseDirectory implementation="java.io.File"&gt;${basedir}&lt;/baseDirectory&gt;
      &lt;/configuration&gt;
      &lt;requirements&gt;
        &lt;requirement&gt;
          &lt;role&gt;org.codehaus.plexus.archiver.Archiver&lt;/role&gt;
          &lt;role-hint&gt;zip&lt;/role-hint&gt;
          &lt;field-name&gt;zipArchiver&lt;/field-name&gt;
        &lt;/requirement&gt;
      &lt;/requirements&gt;
    &lt;/mojo&gt;
  &lt;/mojos&gt;
  &lt;dependencies&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
  &lt;/dependencies&gt;
&lt;/plugin&gt;
</programlisting>
    </example>

    <para>该插件描述符有三个部分：插件的顶层配置包含了如<sgmltag>groupId</sgmltag>和<sgmltag>artifactId</sgmltag>之类的元素；mojo声明；以及依赖声明。让我们仔细解释一下每一部分。</para>

    <section>
      <title>顶层插件描述符元素</title>

      <para><sgmltag>plugin</sgmltag>元素中顶层的配置元素有：</para>

      <variablelist>
        <varlistentry>
          <term>description</term>

          <listitem>
            <para>该元素包含了插件的简短描述。在Zip插件的情况中，该描述为空。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>groupId, artifactId, version</term>

          <listitem>
            <para>就像Maven中的任何其它构件一样，插件也需要唯一的坐标。groupId,
            artifactId,和version用来在Maven仓库中定位插件。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>goalPrefix</term>

          <listitem>
            <para>该元素（目标前缀）用来设置某个特定插件用来引用目标的前缀。如果你看一下Compiler插件的描述符，你会看到<varname>goalPrefix</varname>的值为<varname>compile</varname>，如果你看一下Jar插件的描述符，你会看到<varname>goalPrefix</varname>为<varname>jar</varname>。为自定义插件选择一个独一无二的前缀非常重要。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>isolatedRealm (不赞成使用)</term>

          <listitem>
            <para>该遗留属性不再被Maven使用。它的存在是为了给旧的插件提供向后兼容性。早期版本的Maven使用它提供一种在单独<classname>ClassLoader</classname>中载入插件依赖的机制。Maven扩展使用了<ulink
            url="http://www.codehaus.org">Codehaus</ulink>社区中一个名为<ulink
            url="http://classworlds.codehaus.org/">ClassWorlds</ulink>的项目，创建由<classname>ClassRealm</classname>对象建模的<classname>ClassLoader</classname>对象层次结构。尽管忽略该属性，永远将其设置成<varname>false</varname>。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>inheritedByDefault</term>

          <listitem>
            <para>如果inheritedByDefault（缺省继承）被设置成true，所有在父项目配置的该插件的mojo会在子项目中生效。如果你配置一个mojo在父项目中特定的阶段执行，并且该插件inheritedByDefault属性的值为true，这段执行会被子项目继承。如果inheritedByDefault没有被设置成true，那么定义在父项目中的目标执行不会被子项目继承。</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section>
      <title>Mojo配置</title>

      <para>接下来是每个Mojo的声明。plugin元素包含一个名为mojos的元素，它为每个插件中的mojo元素包含一个mojo元素。每个mojo元素包含如下的配置元素：</para>

      <variablelist>
        <varlistentry>
          <term>goal</term>

          <listitem>
            <para>这是目标的名称。如果你在运行<varname>compiler:compile</varname>目标，<varname>compiler</varname>就是插件的<varname>goalPrefix</varname>，<varname>compile</varname>就是目标的名称。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>description</term>

          <listitem>
            <para>目标的简要描述，当用户使用Help插件生成插件文档的时候，该描述会被显示。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>requiresDirectInvocation</term>

          <listitem>
            <para>如果你将其设置成<varname>true</varname>，那么该目标就只能由用户在命令行显示的执行。如果有人想要将该目标绑定到一个生命周期阶段，Maven会打印错误信息。该元素默认值是<varname>false</varname>。</para>

            <!--TODO: Might want some justification.-->
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>requiresProject</term>

          <listitem>
            <para>指定该目标不能在项目外部运行。目标需要一个带有<acronym>POM</acronym>的项目。<varname>requiresProject</varname>默认的值为<varname>true</varname>。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>requiresReports</term>

          <listitem>
            <para>如果你正创建一个插件，它依赖于报告，那么你就需要将<varname>requiresReports</varname>设置成<varname>true</varname>。例如，如果你创建一个插件用来聚合许多报告的信息，那么就需要将<varname>requiresReports</varname>设置成<varname>true</varname>。该元素默认的值为<varname>false</varname>。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>aggregator</term>

          <listitem>
            <para>当Mojo描述符的<varname>aggregator</varname>设置成<varname>true</varname>的时候，那么该目标只会在Maven执行的时候运行一次，提供该配置是为了让开发人员能够对一系列构建进行总结；例如，创建一个插件来概述构建中所有项目的一类报告。一个<varname>aggregator</varname>设置成<varname>true</varname>的目标应该只在Maven构建的顶层项目中运行。<varname>aggregator</varname>默认值是<varname>false</varname>。Aggregator在未来版本的Maven中很有可能被弃用。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>requiresOnline</term>

          <listitem>
            <para>指定当Maven在离线模式（-o命令行选项）的时候该目标不能运行。如果一个目标依赖于网络资源，你就需要将该元素设置成<varname>true</varname>，那么如果在离线模式下运行，Maven就会输出错误信息。该元素默认值是<varname>false</varname>。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>inheritedByDefault</term>

          <listitem>
            <para>如果<varname>inheritedByDefault</varname>被设置成<varname>true</varname>，在父项目中配置的mojo就会同样在子项目中生效。如果你配置一个mojo在父项目中特定的阶段执行，并且该插件inheritedByDefault属性的值为true，这段执行会被子项目继承。如果inheritedByDefault没有被设置成true，那么定义在父项目中的目标执行不会被子项目继承。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>phase</term>

          <listitem>
            <para>如果用户没有为该目标绑定一个阶段，那么该元素定义一个mojo默认的阶段。如果你没有不指定phase元素，Maven就会要求用户在<acronym>POM</acronym>中显式的指定一个阶段。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>implementation</term>

          <listitem>
            <para>该元素告诉Maven为该Mojo需要初始化什么类。这是一个Plexus组件属性（在Plexus
            <classname>ComponentDescriptor</classname> 中定义）。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>language</term>

          <listitem>
            <para>Maven Mojo默认的语言是<varname>java</varname>。该配置控制Plexus
            <classname>ComponentFactory</classname>初始化该Mojo组件。本章关注于使用Java编写Maven插件，但是你也可以使用其它很多语言来编写Maven插件，如Groovy,
            Beanshell,和Ruby。如果你使用这其中的一种语言来编写插件，那么就需要设置language元素的值。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>instantiationStrategy</term>

          <listitem>
            <para>该属性是一个Plexus组件配置属性，它告诉Plexus如何创建和管理组件实例。在Maven中，所有mojo的<varname>instantiationStrategy</varname>都被配置成<varname>per-lookup</varname>，每次Maven从Plexus获取该mojo的时候，一个新的实例被创建。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>executionStrategy</term>

          <listitem>
            <para>executionStrategy告诉Maven什么时候，怎样运行一个Mojo。可用的值是<varname>once-per-session</varname>和<varname>always</varname>。老实说，任何值都是可用的，这个特殊的属性并不做什么事情，它是从早期Maven设计中遗留下来的。在未来版本的Maven中该属性很有可能被弃用。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>parameters</term>

          <listitem>
            <para>该元素描述Mojo的所有参数。参数名称是什么？参数类型是什么？是否是必须的？每个参数拥有如下的元素：</para>

            <variablelist>
              <varlistentry>
                <term>name</term>

                <listitem>
                  <para>参数名（如 <varname>baseDirectory</varname>）</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>type</term>

                <listitem>
                  <para>参数类型（Java类）（如<classname>java.io.File</classname>）</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>required</term>

                <listitem>
                  <para>参数是否是必须的？如果为<varname>true</varname>，那么当目标运行的时候该参数不能为null。</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>editable</term>

                <listitem>
                  <para>如果一个参数不是可编辑的（如果<varname>editable</varname>被设置成<varname>false</varname>），那么该参数的值就不能在<acronym>POM</acronym>中设置。例如，如果插件描述符定义了<varname>buildDirectory</varname>的值为<varname>${basedir}</varname>，那么在<acronym>POM</acronym>中该值就不能被重写。</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>description</term>

                <listitem>
                  <para>当生成插件文档的时候（使用Help插件），该插件的简短描述。</para>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>configuration</term>

          <listitem>
            <para>该元素为所有Mojo参数提供默认值。本例中为Mojo参数<varname>baseDir</varname>和<varname>buildDirectory</varname>提供了默认值，这里，属性implementation指定了参数的类型（本例中是<classname>java.io.File</classname>），而其元素值包含了一个硬编码的默认值，或者一个Maven属性引用。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>requirements</term>

          <listitem>
            <para>这是一个描述符十分有趣的地方。一个mojo是一个由Plexus管理的组件，而且，由于该原因，它就有机会引用Plexus管理的其它组件。该元素能让你定义对于其它Plexus组件的依赖。</para>

            <!--TODO: Insert an XREF to an example?-->
          </listitem>
        </varlistentry>
      </variablelist>

      <!--TODO: The following paragraph is Eric's and it is in the wrong place.-->

      <para>虽然你的确应该能够读懂插件描述符，但你几乎从来不需要去手工的编写一个描述符文件。插件描述符会根据Mojo的一组注解自动的生成。</para>
    </section>

    <section>
      <title>插件依赖</title>

      <para>最后，插件描述符像Mave项目一样声明了一组依赖。当Maven使用插件的时候，它会在运行插件目前之前下载所有需要的依赖。在本例中，该插件依赖于Jakarta
      Commons IO 版本 1.3.2 。</para>
    </section>
  </section>

  <section id="writing-plugins-intro">
    <title>编写自定义插件</title>

    <para>在你编写自定义插件的时候，你实际上是要编写一系列的Mojo（目标）。每个Mojo是一个但是的Java类，它包含了一系列标注来告诉Maven如何生成插件描述符。在编写Mojo类之前，你需要使用正确的打包类型和POM来创建一个Maven项目。</para>

    <section>
      <title>创建一个插件项目</title>

      <para>要创建一个插件项目，你应该使用Maven
      Archetype插件。一下的命令会创建一个插件，其<varname>groupId</varname>是<varname>org.sonatype.mavenbook.plugins</varname>，<varname>artifactId</varname>是<varname>first-maven-plugin</varname>：</para>

      <screen>$ <command>mvn archetype:create \
  -DgroupId=org.sonatype.mavenbook.plugins \
  -DartifactId=first-maven-plugin \
  -DarchetypeGroupId=org.apache.maven.archetypes \
  -DarchetypeArtifactId=maven-archetype-mojo</command></screen>

      <para>Archetype插件会创建一个名为my-first-plugin的目录，其包含了如下的POM：</para>

      <example>
        <title>一个插件项目的POM</title>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;first-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;maven-plugin&lt;/packaging&gt;
  &lt;name&gt;first-maven-plugin Maven Mojo&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;
      &lt;artifactId&gt;maven-plugin-api&lt;/artifactId&gt;
      &lt;version&gt;2.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para>在一个插件项目的POM中最重要的元素是打包类型，其值为<varname>maven-plugin</varname>。该打包类型会定制Maven的生命周期，使其包含创建插件描述符必要的目标。插件生命周期在<xref
      linkend="sect-plugin-lifecycle" />中介绍，它和Jar生命周期类似，但有三个例外：<varname>plugin:descriptor</varname>被绑定到<varname>generate-resources</varname>阶段，<varname>plugin:addPluginArtifactMetadata</varname>被添加到<varname>package</varname>阶段，<varname>plugin:updateRegistry</varname>被添加到<varname>install</varname>阶段。</para>

      <para>插件项目的POM中另一个重要的部分是，它有一个对于Maven Plugin
      API的依赖。该项目依赖于<varname>maven-plugin-api</varname>的2.0版本，同时它也有一个测试范围的JUnit依赖。</para>
    </section>

    <section>
      <title>一个简单的Java Mojo</title>

      <para>本章，我们将介绍一个用Java编写的Maven
      Mojo。你项目中每一个Mojo都要实现<classname>org.apache.maven.plugin.Mojo</classname>接口，下例中的<classname>Mojo</classname>通过扩展<classname>org.apache.maven.plugin.AbstractMojo</classname>类实现了该接口。在我们深入Mojo的代码之前，让我们花一些时间看一下Mojo接口。Mojo提供过了如下的方法：</para>

      <variablelist>
        <varlistentry>
          <term><methodname>void setLog( org.apache.maven.monitor.logging.Log
          log )</methodname></term>

          <listitem>
            <para>每一个Mojo实现都必须提供一种方法让插件能够和某个特定目标的过程相交流。该目标成功了么？或者，是否在运行目标的时候遇到了问题？当Maven加载并运行Mojo的时候，它会调用<methodname>setLog()</methodname>方法，为Mojo实例提供正确的日志目标，以让你在自定义插件中使用。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>protected Log getLog()</methodname></term>

          <listitem>
            <para>Maven会在Mojo运行之前调用<methodname>setLog()</methodname>方法，然后你的Mojo就可以通过调用<methodname>getLog()</methodname>获得日志对象。你的Mojo应该去调用这个<classname>Log</classname>对象的方法，而不是直接将输出打印到标准输出或者控制台。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>void execute() throws
          org.apache.maven.plugin.MojoExecutionException</methodname></term>

          <listitem>
            <para>轮到运行你目标的时候，Maven就会调用该方法。</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>Mojo接口只关心两件事情：目标运行的结果记录日志，以及运行一个目标。当你编写自定义插件的时候，你会要扩展<classname>AbstractMojo</classname>。<classname>AbstractMojo</classname>处理<varname>setLog()</varname>和<varname>getLog()</varname>的实现，并包含一个抽象的<methodname>execute()</methodname>方法。在你扩展<classname>AbstractMojo</classname>的时候，你所需要做的只是实现<methodname>execute()</methodname>方法。<xref
      linkend="ex-simple-echomojo" />展示了一个简单的Mojo实现，它只是打印一条简单的信息到控制台。</para>

      <example id="ex-simple-echomojo">
        <title>一个简单的EchoMojo</title>

        <programlisting language="java">package org.sonatype.mavenbook.plugins;

import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;

/**
 * Echos an object string to the output screen.
 * @goal echo
 */
public class EchoMojo extends AbstractMojo
{
    /**
     * Any Object to print out.
     * @parameter expression="${echo.message}" default-value="Hello Maven World..."
     */
    private Object message;

    public void execute()
        throws MojoExecutionException, MojoFailureException
    {
        getLog().info( message.toString() );
    }
}
</programlisting>
      </example>

      <para>如果你在前一节中创建的项目的<varname>${basedir}</varname>下，按照路径<filename>src/main/java/<filename>org/sonatype/mavenbook/mojo/EchoMojo.java</filename></filename>创建该Mojo，然后运行<command>mvn
      install</command>，你就可以在命令行直接调用该目标。</para>

      <screen>$ <command>mvn org.sonatype.mavenbook.plugins:first-maven-plugin:1.0-SNAPSHOT:echo</command></screen>

      <para>这一长串命令行是<command>mvn</command>后面加上<varname>groupId:artifactId:version:goal</varname>。在你运行该命令之后你应该会看到一个包含了目标echo信息的输出：“Hello
      Maven World”。如果你想要自定义该信息，你可以如下在命令行传入信息参数：</para>

      <screen>$ <command>mvn org.sonatype.mavenbook.plugins:first-maven-plugin:1.0-SNAPSHOT:echo \
             -Decho.message="The Eagle has Landed"</command></screen>

      <para>仍然按照前一条命令运行<classname>EchoMojo</classname>，会得到这样的输出：“The Eagle has
      Landed”。</para>
    </section>

    <section>
      <title>配置插件前缀</title>

      <para>在命令行声明groupId，artifactId，version和goal十分麻烦。为了处理这个问题，Maven为插件分配了前缀。你可以使用插件前缀jar，然后使用命令<command>mvn
      jar:jar</command>，而非：</para>

      <screen>$ mvn org.apache.maven.plugins:maven-jar-plugin:2.2:jar</screen>

      <para>Maven是如何解析<varname>jar:jar</varname>至<varname>org.apache.mven.plugins:maven-jar:2.3</varname>的呢？Maven查看Maven仓库中的一个文件然后获得一些列含有特定groupId的插件。默认情况下，Maven被配置成从两个组寻找插件：<varname>org.apache.maven.plugins</varname>和<varname>org.codehaus.mojo</varname>。当你指定一个新的插件前缀如<command>mvn
      hibernate3:hbm2ddl</command>的时候，Maven会为了正确的插件前缀扫描仓库元数据。首先，Maven会扫描<varname>org.apache.maven.plugins</varname>组来查找插件前缀<varname>hibernate3</varname>。如果它没有在这个组中找到该插件前缀，它就会接着扫描<varname>org.codehaus.mojo</varname>组的元数据。</para>

      <para>当Maven针对某个特定的groupId扫描元数据的时候，它从Maven仓库获取一个XML文件，该文件包含了这个组中构件的元数据。该XML文件对于每个参考实现仓库来说都是明确的，如果你没有使用过一个自定义仓库，你就能在你的本地Maven仓库（<filename>~/.m2/repository</filename>）路径<filename>org/apache/maven/plugins/maven-metadata-central.xml</filename>下看到组<varname>org.apache.maven.plugins</varname>的Maven元数据。<xref
      linkend="ex-maven-metadata" />展示了这样一个XML文件的代码片段。</para>

      <example id="ex-maven-metadata">
        <title>Maven插件组的Maven元数据</title>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;metadata&gt;
  &lt;plugins&gt;
    &lt;plugin&gt;
      &lt;name&gt;Maven Clean Plugin&lt;/name&gt;
      &lt;prefix&gt;clean&lt;/prefix&gt;
      &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
    &lt;plugin&gt;
      &lt;name&gt;Maven Compiler Plugin&lt;/name&gt;
      &lt;prefix&gt;compiler&lt;/prefix&gt;
      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
    &lt;plugin&gt;
      &lt;name&gt;Maven Surefire Plugin&lt;/name&gt;
      &lt;prefix&gt;surefire&lt;/prefix&gt;
      &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
    ...
  &lt;/plugins&gt;
&lt;/metadata&gt;</programlisting>
      </example>

      <para>正如你在<xref
      linkend="ex-maven-metadata" />中所看到的，你本地仓库的<filename>maven-metadata-central.xml</filename>文件能帮助你运行<command>mvn
      surefire:test</command>。Maven扫描<varname>org.apache.maven.plugins</varname>和<varname>org.codehaus.mojo</varname>：<varname>org.apache.maven.plugins</varname>中的插件被认为是核心Maven插件，而<varname>org.codehaus.mojo</varname>中的被认为是额外的插件。Apache
      Maven项目管理<varname>org.apache.maven.plugins</varname>组，而另外一个独立的开源社区管理Codehaus
      Mojo项目。如果你想要发布插件到你自己的groupId下，你就需要让Maven自动扫描你的groupId以获得插件前缀，你就可以通过Maven
      settings自定义Maven需要扫描的插件组。</para>

      <para>如果你想要通过<varname>first:echo</varname>命令就能运行<varname>first-maven-plugin</varname>的echo目标，如所示，添加<varname>org.sonatype.mavenbook.plugins</varname>
      groupId至你的<filename>~/.m2/settings.xml</filename>文件中。这会让Maven优先扫描<varname>org.sonatype.mavenbook.plugins</varname>插件组。</para>

      <example id="ex-plugin-groups">
        <title>在Maven Settings中自定义插件组</title>

        <programlisting language="xml">&lt;settings&gt;
  ...
  &lt;pluginGroups&gt;
    &lt;pluginGroup&gt;org.sonatype.mavenbook.plugins&lt;/pluginGroupd&gt;
  &lt;/pluginGroups&gt;
&lt;/settings&gt;</programlisting>
      </example>

      <para>你可以在任何目录运行<command>mvn
      first:echo</command>，并看到Maven正确解析了目标前缀。这样子行得通是因为我们遵循了Maven插件的命名约定。如果你的插件有一个artifactId，并且它遵循模式<varname>maven-first-plugin</varname>，或者<varname>first-maven-plugin</varname>。Maven就会自动为你的插件赋予前缀<varname>first</varname>。换句话说，当Maven
      Plugin插件为你的插件生成插件描述符的时候，你不需要显式的为你的项目设定<varname>goalPrefix</varname>，<varname>当你的artifactId符合如下模式的时候，plugin:descriptor</varname>目标会从你插件的artifactId中抽取前缀。</para>

      <itemizedlist>
        <listitem>
          <para><varname>${prefix}-maven-plugin</varname>, OR</para>
        </listitem>

        <listitem>
          <para><varname>maven-${prefix}-plugin</varname></para>
        </listitem>
      </itemizedlist>

      <para>如果你想要显式的设定插件前缀，你需要配置Maven Plugin插件。Maven
      Plugin插件被用来构建插件描述符，并在打包和加载阶段运行一些插件特定的任务。Maven
      Plugin插件可以像其它任何插件一样在build元素下配置。要为你的插件设置插件前缀，在项目<varname>first-maven-plugin</varname>的pom.xml中添加如下的build元素：</para>

      <example id="ex-plugin-prefix">
        <title>Configuring a Plugin Prefix</title>

        <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.plugins&lt;/groupId&gt;
  &lt;artifactId&gt;first-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;maven-plugin&lt;/packaging&gt;
  &lt;name&gt;first-maven-plugin Maven Mojo&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;artifactId&gt;maven-plugin-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.3&lt;/version&gt;
        &lt;configuration&gt;
          &lt;goalPrefix&gt;blah&lt;/goalPrefix&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;
      &lt;artifactId&gt;maven-plugin-api&lt;/artifactId&gt;
      &lt;version&gt;2.0&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>
      </example>

      <para><xref
      linkend="ex-plugin-prefix" />设置了插件前缀为<varname>blah</varname>。如果在<filename>~/.m2/settings.xml</filename>中的<sgmltag>pluginGroups</sgmltag>下添加了<varname>org.sonatype.mavenbook.plugins</varname>元素，你就应该能够在任何目录通过<command>mvn
      blah：echo</command>命令运行<classname>EchoMojo</classname>。</para>
    </section>

    <section>
      <title>插件中的日志</title>

      <para>Maven通过在运行你的Mojo之前调用<methodname>setLog()</methodname>来连接你的Mojo至日志提供程序。该提供程序提供了一个<classname>org.apache.maven.monitor.logging.Log</classname>的实现。该类暴露了一些你可以用来和用户交流信息的方法。这个<classname>Log</classname>类提供了很多日志级别，与<ulink
      url="http://logging.apache.org/">Log4J</ulink>提供的API十分类似。每个级别：debug，info，error，warn，都有一些列可用的方法。为了节省时间，我们只列出了debug级别的方法：</para>

      <variablelist>
        <varlistentry>
          <term><methodname>void debug( CharSequence message
          )</methodname></term>

          <listitem>
            <para>打印信息至debug日志级别。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>void debug( CharSequence message, Throwable t
          )</methodname></term>

          <listitem>
            <para>打印信息至debug日志级别，并包含一个<classname>Throwable</classname>（<classname>Exception</classname>或者<classname>Error</classname>）的堆栈信息。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><methodname>void debug( Throwable t )</methodname></term>

          <listitem>
            <para>打印一个<classname>Throwable</classname>（<classname>Exception</classname>或者<classname>Error</classname>）的堆栈信息。</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>每个级别暴露同样的一组方法。这四个日志级别服务于不同的目的。debug级别是为了调试目的，人们用来观察mojo运行的详细情况。你应该使用debug日志级别来提供Mojo运行尽可能详细的细节，但你从不应该去假设用户会看到debug级别信息。info级别是为了生成一些正常操作的信息。如果你构建一个插件使用编译器来编译代码，你可能就需要打印编译的输出至屏幕。</para>

      <para>warn日志级别用来记录一些非预期的，但你的Mojo还能够处理的事件和错误。如果你试图运行编译Ruby源码的插件，而实际上没有可用的Ruby源码，你就需要打印一个警告信息，然后继续运行。警告（warn）不是致命的，但是错误（error）就是一些终止程序运行的情况。对于那些完全非预期的错误情况，这里有error日志级别。如果你不再能够继续运行一个Mojo，你就需要使用error。如果你在编写一个Mojo编译Java源码，但编译器不可用，你就需要打印一条信息到error级别，然后传递一条异常，以让Maven能够输出给用户。你应该假设用户能够看到大多数的info信息，以及所有的error信息。</para>
    </section>

    <section>
      <title>Mojo类注解</title>

      <para>在<varname>first-maven-plugin</varname>中，我们并没有编写插件描述符，我们依赖于Maven从源码生成插件描述符。该描述符根据你插件项目的POM信息以及<classname>EchoMojo</classname>类上一系列的注解生成。<classname>EchoMojo</classname>仅仅声明了一个<classname>@goal</classname>注解，这里偶一个注解的列表，你可以将其用到Mojo实现上。</para>

      <para><variablelist>
          <varlistentry>
            <term>@goal &lt;goalName&gt;</term>

            <listitem>
              <para>这是唯一必需的注解，它给予目标一个插件中唯一的名称。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@requiresDependencyResolution &lt;requireScope&gt;</term>

            <listitem>
              <para>标记该mojo在可以运行之前，需要特定范围（或者一个暗指的范围）的依赖。支持的范围有compile，runtime，和test。如果该注解有一个值为test，那么就是告诉Maven除非测试范围的所有依赖都被正确解析了，否则该mojo不能运行。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@requiresProject (true|false)</term>

            <listitem>
              <para>标记该mojo必须在一个项目中运行，默认为true。这一点插件类型和骨架类型（archetype）相反，后者默认为false。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@requiresReports (true|false)</term>

            <listitem>
              <para>如果你正创建一个依赖于报告的项目，你就需要将<varname>requiresReports</varname>设置成true。该注解默认的值是false。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@aggregator (true|false)</term>

            <listitem>
              <para>一个<varname>aggregator</varname>设置成true的Mojo在Maven运行的时候只会被执行一次，有了该选项，插件开发者就可以汇总一系列构建的输出；例如，创建一个插件用来汇总一次构建包含的所有项目的报告。<varname>aggregator</varname>设置成true的目标只针对Maven构建的顶层项目运行。该注解默认的值是false。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@requiresOnline (true|false)</term>

            <listitem>
              <para>当该注解的值是true的时候，Maven在脱机模式运行的时候该目标运行就会失败。Maven会抛出一个错误。默认值：false。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@requiresDirectInvocation</term>

            <listitem>
              <para>当设置成true的时候，只有当用户显式的从命令行触发的时候，该插件才能得以执行。如果有人试图将其绑定到一个生命周期阶段，Maven就会抛出一个错误。默认值是false。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@phase &lt;phaseName&gt;</term>

            <listitem>
              <para>该注解指定目标默认的生命周期阶段。如果你将该目标的执行配置到了pom.xml而且没有指定一个阶段。Maven就会使用该注解的值将其绑定到一个默认的阶段。</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>@execute [goal=goalName|phase=phaseName
            [lifecycle=lifecycleId]]</term>

            <listitem>
              <para>该注解有很多种使用方式。如果提供了一个阶段，Maven就会执行一个平行的生命周期（直到指定的阶段）。这个单独执行的结果可以通过Maven属性<varname>${executedProperty}</varname>供插件使用。</para>

              <para>第二种使用该注解的方式是使用<varname>prefix:goal</varname>标记指定一个显式的目标。当你仅仅指定一个目标的时候，Maven会在一个平行的环境中执行该目标，不会影响当前的Maven构建。</para>

              <para>第三种使用该注解的方式是，使用一个生命周期定义文件，并指定这个生命周期的一个阶段。</para>

              <programlisting language="java">@execute phase="package" lifecycle="zip"
@execute phase="compile"
@execute goal="zip:zip"</programlisting>
            </listitem>
          </varlistentry>
        </variablelist></para>

      <para>如果你看一下<classname>EchoMojo</classname>的源码，你会注意到Maven并没有使用Java
      5的标准注解。而是使用了<ulink url="http://commons.apache.org/attributes/">Commons
      Attributes</ulink>。在注解成为Java语言的一部分之前，Commons
      Attributes为Java程序员提供了一种使用注解的方式。为什么Maven不使用Java 5的注解呢？这是因为Maven是针对Java
      5之前的<acronym>JVM</acronym>设计的。因为Maven必须支持Java比较老的版本，所以它不能使用任何Java
      5的新特性。</para>
    </section>

    <section>
      <title>当Mojo失败的时候</title>

      <para>Mojo中的<methodname>execute()</methodname>方法抛出两个异常，<classname>MojoExecutionException</classname>和<classname>MojoFailureException</classname>。这两个异常的区别既微妙又重要，这要看当目标运行“失败”的时候发生了什么。一个<classname>MojoExecutionException</classname>应该是一个致命的异常，发生了一些不可恢复的错误。如果有什么事情导致构建完全终止，你就需要抛出一个<classname>MojoExecutionException</classname>；比如说你正试图往磁盘写数据，但没有可用空间，或者，你试图发布构件到一个远程仓库，但是连接不了远程服务器。如果没有机会继续构建，就抛出一个<classname>MojoExecutionException</classname>；发生了一些严重的事情，你希望停止构建并让用户看到“BUILD
      ERROR”信息。</para>

      <para>而<classname>MojoFailureException</classname>就相对没有那么严重，一个目标可以失败，但它可能并不是Maven构建的世界末日。一个单元测试可以失败，或者MD5校验和可以失败；两者都是潜在的问题，但是你不会想要抛出一个异常去终止整个构建。在这种情况下，你可以抛出一个<classname>MojoFailureException</classname>。当Maven遇到项目失败的时候，他会提供不同的“弹性”设置。如下所述：</para>

      <para>当你运行一个Maven构建的时候，它会包含一系列的项目，每个项目可以成功或者失败。你可以三种可选的失败模式：</para>

      <variablelist>
        <varlistentry>
          <term>mvn -ff</term>

          <listitem>
            <para>最快失败模式：Maven会在遇到第一个失败的时候失败（停止）。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>mvn -fae</term>

          <listitem>
            <para>最后失败模式：Maven会在构建最后失败（停止）。如果Maven
            refactor中一个失败了，Maven会继续构建其它项目，并在构建最后报告失败。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>mvn -fn</term>

          <listitem>
            <para>从不失败模式：Maven从来不会为一个失败停止，也不会报告失败。</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>如果你正在运行一个持续集成构建，不管单个项目构建成败与否都要继续构建，你可能想要忽略失败。作为一个插件开发者，你必须根据你某个特定的失败条件来判断使用<classname>MojoExecutionException</classname>还是<classname>MojoFailureExeception</classname>。</para>
    </section>
  </section>

  <section>
    <title>Mojo参数</title>

    <para>通过参数配置Mojo，和<methodname>execute()</methodname>方法及Mojo注解相比同样重要。本节讲述有关Mojo参数的配置和主题。</para>

    <section>
      <title>为Mojo参数提供值</title>

      <para>在EchoMojo中我们使用如下的注解声明了message参数。</para>

      <programlisting language="java">/**
 * Any Object to print out.
 * @parameter
 *       expression="${echo.message}"
 *       default-value="Hello Maven World"
 */
private Object message;
</programlisting>

      <para>该参数的默认表达式是<varname>${echo.message}</varname>，意思是Maven会使用<varname>echo.message</varname>属性的值来设置message的值。如果<varname>echo.message</varname>属性的值是null，<classname>@parameter</classname>注解的default-value属性就会被使用。除了使用<varname>echo.message</varname>属性，我们也可以在项目的POM中配置EchoMojo的message参数的值。</para>

      <para>有很多中方式可以填充<classname>EchoMojo</classname>的message参数的值。首先我们可以从命令行传入一个值（假设你已经将<varname>org.sonatype.mavenbook.plugins</varname>添加到你的<sgmltag>pluginGroups</sgmltag>中）：</para>

      <screen>$ mvn first:echo -Decho.message="Hello Everybody"</screen>

      <para>我们也可以通过在POM或者settings.xml中设定一个属性来指定该message参数的值：</para>

      <programlisting language="xml">&lt;project&gt;
  ...
  &lt;properties&gt;
    &lt;echo.message&gt;Hello Everybody&lt;/echo.message&gt;
  &lt;/properties&gt;
&lt;/project&gt;
</programlisting>

      <para>该参数还可以直接通过配置插件来进行配置。如果我们想要直接自定义message参数，我们可以使用如下的build配置。下面的配置绕开了echo.message属性，而是在插件配置中填充Mojo参数：</para>

      <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.sonatype.mavenbook.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;first-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;configuration&gt;
          &lt;message&gt;Hello Everybody!&lt;/message&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;</programlisting>

      <para>如果我们想要在一个生命周期的不同阶段中运行<classname>EchoMojo</classname>两次，并且希望每次运行都能自定义message参数，我们可以在如下在POM中的execution级别配置这个参数值：</para>

      <programlisting language="xml">&lt;build&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.sonatype.mavenbook.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;first-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id&gt;first-execution&lt;/id&gt;
            &lt;phase&gt;generate-resources&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;echo&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;message&gt;The Eagle has Landed!&lt;/message&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
          &lt;execution&gt;
            &lt;id&gt;second-execution&lt;/id&gt;
            &lt;phase&gt;validate&lt;/phase&gt;
            &lt;goals&gt;
              &lt;goal&gt;echo&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
              &lt;message&gt;${project.version}&lt;/message&gt;
            &lt;/configuration&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/build&gt;</programlisting>

      <para>虽然上面的配置样例看起来有些啰嗦，但它展示了Maven的弹性。在前面的配置样例中，我们将<classname>EchoMojo</classname>同时绑定到了默认Maven生命周期的<varname>validate</varname>和<varname>generate-resources</varname>阶段。第一次执行被绑定到了<varname>generate-resources</varname>，它为message参数提供了字符串值“he
      Eagle has
      Landed!”。第二次运行则被绑定到了<varname>validate</varname>阶段，它提供了一个属性引用<varname>${project.version}</varname>。当你为该项目运行<command>mvn
      install</command>的时候，你会看到<varname>first:echo</varname>目标执行了两次，并打印了不同的信息。</para>
    </section>

    <section>
      <title>多值的Mojo参数</title>

      <para>插件的参数可以接受多于一个的值。看一下<xref
      linkend="ex-plugin-multivalue" />中的<classname>ZipMojo</classname>。参数<varname>includes</varname>和<varname>excludes</varname>都是多值的<classname>String</classname>数组，它们为一个创建ZIP文件的组件指定了包含和排除的模式。</para>

      <example id="ex-plugin-multivalue">
        <title>一个带有多值参数的插件</title>

        <programlisting language="java">package org.sonatype.mavenbook.plugins

/**
 * Zips up the output directory.
 * @goal zip
 * @phase package
 */
public class ZipMojo extends AbstractMojo
{
    /**
     * The Zip archiver.
     * @parameter expression="${component.org.codehaus.plexus.archiver.Archiver#zip}"
     */
    private ZipArchiver zipArchiver;

    /**
     * Directory containing the build files.
     * @parameter expression="${project.build.directory}"
     */
    private File buildDirectory;

    /**
     * Base directory of the project.
     * @parameter expression="${basedir}"
     */
    private File baseDirectory;

    /**
     * A set of file patterns to include in the zip.
     * @parameter alias="includes"
     */
    private String[] mIncludes;

    /**
     * A set of file patterns to exclude from the zip.
     * @parameter alias="excludes"
     */
    private String[] mExcludes;

    public void setExcludes( String[] excludes ) { mExcludes = excludes; }

    public void setIncludes( String[] includes ) { mIncludes = includes; }

    public void execute()
        throws MojoExecutionException
    {
        try {
            zipArchiver.addDirectory( buildDirectory, includes, excludes );
            zipArchiver.setDestFile( new File( baseDirectory, "output.zip" ) );
            zipArchiver.createArchive();
        } catch( Exception e ) {
            throw new MojoExecutionException( "Could not zip", e );
        }
    }
}
</programlisting>

        <para>要配置一个多值的Mojo参数，你应该为这类参数使用一组元素。如果这个多值参数的名称是includes，你就可以使用一个includes元素，它包含一组include子元素。如果这个多值参数的名称是excludes，你就应该使用带有exclude子元素的excludes元素。要配置<classname>ZipMojo</classname>使其忽略所有以.txt及波浪号结尾的文件，你可以使用如下的插件配置。</para>
      </example>

      <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.sonatype.mavenbook.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;zip-maven-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
          &lt;excludes&gt;
            &lt;exclude&gt;**/*.txt&lt;/exclude&gt;
            &lt;exclude&gt;**/*~&lt;/exclude&gt;
          &lt;/excludes&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</programlisting>
    </section>

    <section>
      <title>依赖于一个Plexus组件</title>

      <para>一个Mojo是一个由名为Plexus的Ioc容器管理的组件。Mojo可以通过使用<classname>@parameter或</classname><classname>@component</classname>注解声明Mojo参数，然后依赖于其它Plexu管理的组件。<xref
      linkend="ex-plugin-multivalue" />展示了<classname>ZipMojo</classname>使用<classname>@parameter</classname>注解依赖于一个Plexus组件，该依赖也可以使用<classname>@component</classname>注解来声明。</para>

      <example>
        <title>依赖于一个Plexus组件</title>

        <programlisting language="java">/**
 * The Zip archiver.
 * @component role="org.codehaus.plexus.archiver.Archiver" roleHint="zip"
 */
private ZipArchiver zipArchiver;</programlisting>
      </example>

      <para>当Maven初始化该Mojo的时候，它会尝试通过指定的role和role
      hint来获取Plexus组件。在该例中，这个Mojo关联到一个ZipArchiver组件，后者能帮助<classname>ZipMojo</classname>创建ZIP文件。</para>

      <!--TODO: OK, we need more here.  How do I get my hands on components?  How to a bundle components?-->
    </section>

    <section>
      <title>Mojo参数注解</title>

      <para>除非你坚持要手工编写自己的插件描述符，否则你完全不需要编写那个XML文件。Maven
      Plugin插件有一个<varname>plugin:descriptor</varname>目标绑定到了generate-resources阶段。该目标根据Mojo的注解生成插件描述符。要配置Mojo参数，你应该使用下列的注解，将其声明到私有成员变量上。你也可以在公有setter方法上使用这些注解，但Maven插件一般的约定是直接注解私有成员变量。</para>

      <variablelist>
        <varlistentry>
          <term>@parameter [alias="someAlias"]
          [expression="${someExpression}"] [default-value="value"]</term>

          <listitem>
            <para>标记一个私有字段（或者一个setter方法）为一个参数。<varname>alias</varname>提供该参数的名称。如果没有<varname>alias</varname>，Maven会使用变量名为参数名。<varname>expression</varname>是一个Maven用来计算并获值的一个表达式。通常这个表达式只是一个属性引用如<varname>${echo.message}</varname>。<varname>default-value</varname>是当表达式不能求得值，POM的插件配置中也没有显式提供时，Mojo会使用的值。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@required</term>

          <listitem>
            <para>如果使用了该注解，那么在该Mojo运行前该参数就必须要有一个可用的值。如果Maven试图运行该Mojo的时候该参数的值为null，Maven就会抛出一个错误。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@readonly</term>

          <listitem>
            <para>如果使用该注解，用户就不能从POM直接配置这个参数。你就需要parameter注解的expression属性。例如，如果你想要确保一个特定参数的值永远是POM中finalName属性的值，你就可以使用表达式<varname>${build.finalName}</varname>，并添加这个<classname>@readOnly</classname>注解。这样，用户就只能通过更改POM中<varname>finalName</varname>的值来更改这个参数的值。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@component</term>

          <listitem>
            <para>告诉Maven使用Plexus组件填充该字段。一个正确的<classname>@component</classname>注解值如下：</para>

            <programlisting language="java">@component role="org.codehaus.plexus.archiver.Archiver" roleHint="zip"
</programlisting>

            <para>该配置的效果是可以从Plexus获得<classname>ZipArchiver</classname>组件。<classname>ZipArchiver</classname>是一个对应role
            hint为<varname>zip</varname>的Archiver组件。除了@component注解，你也可以使用@parameter注解和一个expression属性，如：</para>

            <programlisting language="java">@parameter expression="${component.org.codehaus.plexus.archiver.Archiver#zip}"
</programlisting>

            <para>虽然两种注解的效果一样，但对于配置Plexus组件依赖来说，<classname>@component</classname>注解是更推荐的方式。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@deprecated</term>

          <listitem>
            <para>该参数以过期，不再推荐使用。用户可以继续配置该参数，但会得到一条警告信息。</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section>
    <title>插件和Maven生命周期</title>

    <para>在<xref
    linkend="lifecycle" />中，你学习了生命周期可以通过打包类型定制。一个插件可以同时引入一个新的打包类型，并自定义该生命周期。在本节中，我们将会学习如果通过一个自定义的Maven插件来自定义生命周期。你同时也会看到如何让Mojo在平行的生命周期中执行。</para>

    <section>
      <title>执行平行的生命周期</title>

      <para>让我们假设你编写了一些目标，它们依赖于前一个构建的输出。也许<classname>ZipMojo</classname>目标只有在拥有归档输出的前提下才能运行。你可以使用Mojo类的<classname>@execute</classname>注解来指定这样的前置目标。该注解会让Maven生成一个平行的构建，并在这个平行的Maven实例中执行一个目标或者生命周期，该运行并不会影响当前构建。也许你编写了一个Mojo，它每天只运行一次，它首先会运行<command>mvn
      install</command>，然后将所有的输出打包至某种自定义的分发格式。你的Mojo描述符可以告诉Maven，在运行这个自定义Mojo之前，你想要运行默认生命周期的所有直到install的阶段，然后以属性<varname>${executedProject}</varname>的形式将项目结果暴露给你的Mojo。然后你就可以在进行某种后期处理之前引用那个项目的属性。</para>

      <para>另一种可能性是，你有一个目标做一些与默认生命周期完全无关的工作。让我们考虑这样一个例子，你有一个目标使用LAME将WAV文件转换成MP3，但在这之前你需要运行一个生命周期，将MIDI文件转换成WAV。（你可以用Maven做任何事，这里的例子并没有太“离谱”）你已经创建了一个“midi-sound”生命周期，现在你想要包含midi-sound生命周期install阶段的输出，而现在你自己的web应用项目的打包类型是war。由于你的项目在war打包类型生命周期运行，你需要让mojo能够fork一个完全独立的，使用midi-sound的生命周期。你可以通过在你的mojo上添加注解<varname>@execute
      lifecycle="midi-source" phase="install"</varname>来达到这样的目的。</para>

      <variablelist>
        <varlistentry>
          <term>@execute goal="&lt;goal&gt;"</term>

          <listitem>
            <para>会在执行当前目标之前运行声明的目标。目标名称使用<varname>prefix:goal</varname>标记指定。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@execute phase="&lt;phase&gt;"</term>

          <listitem>
            <para>在执行当前生命周期之前，fork出另一个构建生命周期（直到指定的阶段）。如果没有指定生命周期，Maven会使用当前构建的生命周期。</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>@execute lifecycle="&lt;lifecycle&gt;"
          phase="&lt;phase&gt;"</term>

          <listitem>
            <para>会执行给定的生命周期。自定义的生命周期可以在<filename>META-INF/maven/lifecycle.xml</filename>中定义。</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section>
      <title>创建自定义的生命周期</title>

      <para>自定义生命周期必须在插件项目的<filename>META-INF/maven/lifecycle.xml</filename>文件中定义。你可以引入这个定义在<filename>src/main/resources</filename>下的<filename>META-INF/maven/lifecycle.xml</filename>文件。以下的<filename>lifecycle.xml</filename>声明了一个名为<varname>zipcycle</varname>的生命周期，它在<varname>package</varname>阶段包含了一个<varname>zip</varname>目标。</para>

      <para><example>
          <title>在lifecycle.xml中自定义生命周期</title>

          <programlisting language="xml">&lt;lifecycles&gt;
  &lt;lifecycle&gt;
    &lt;id&gt;zipcycle&lt;/id&gt;
    &lt;phases&gt;
      &lt;phase&gt;
        &lt;id&gt;package&lt;/id&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;goals&gt;
              &lt;goal&gt;zip&lt;/goal&gt;
            &lt;/goals&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/phase&gt;
    &lt;/phases&gt;
  &lt;/lifecycle&gt;
&lt;/lifecycles&gt;
</programlisting>
        </example></para>

      <para>如果你想要在另一个构建中运行这个<varname>zipcycle</varname>生命周期，你可以创建一个<classname>ZipForkMojo</classname>，然后使用<classname>@execute</classname>注解来告诉Maven，当<classname>ZipForkMojo</classname>运行的时候，逐步通过<varname>zipcycle</varname>生命周期的阶段。</para>

      <para><example>
          <title>在Mojo中Fork一个自定义生命周期</title>

          <programlisting language="java">/**
 * Forks a zip lifecycle.
 * @goal zip-fork
 * @execute lifecycle="zipcycle" phase="package"
 */
public class ZipForkMojo extends AbstractMojo
{
  public void execute()
    throws MojoExecutionException
  {
    getLog().info( "doing nothing here" );
  }
}
</programlisting>
        </example></para>

      <para>运行<classname>ZipForkMojo</classname>的时候会fork出另一个生命周期。如果你配置了你插件的前缀为zip，运行<varname>zip-fork</varname>会得到类似于如下输出的结果：</para>

      <screen>$ mvn zip:zip-fork
[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'zip'.
[INFO] ----------------------------------------------------------------------------
[INFO] Building Maven Zip Forked Lifecycle Test
[INFO]    task-segment: [zip:zip-fork]
[INFO] ----------------------------------------------------------------------------
[INFO] Preparing zip:zip-fork
[INFO] [site:attach-descriptor]
[INFO] [zip:zip]
[INFO] Building zip: ~/maven-zip-plugin/src/projects/zip-lifecycle-test/target/output.zip
[INFO] [zip:zip-fork]
[INFO] doing nothing here
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESSFUL
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1 second
[INFO] Finished at: Sun Apr 29 16:10:06 CDT 2007
[INFO] Final Memory: 3M/7M
[INFO] ------------------------------------------------------------------------
</screen>

      <para>调用<varname>zip-fork</varname>会衍生出另外一个生命周期，Maven运行<varname>zipcycle</varname>生命周期，然后从<classname>ZipFormMojo</classname>的execute方法打印信息。</para>
    </section>

    <section>
      <title>覆盖默认生命周期</title>

      <para>你已经创建了自己的生命周期，并能在一个Mojo中将其衍生使用。下一个你可能要问的问题是，如何覆盖默认的生命周期。如何如何创建定制的生命周期并将其绑定到项目上？在<xref
      linkend="lifecycle" />中，我们看到了项目的打包类型定义了项目的生命周期。所有打包类型都有差异；war绑定不同的目标到package阶段，自定义的生命周期如来自Israfil
      Flex
      3的swf绑定不同的目标到compile阶段。在你创建自定义生命周期的时候，你可以通过为插件提供一些Plexus配置，将生命周期绑定到特定的打包类型。</para>

      <para>要为新的生命周期定义新的打包类型，你需要配置Plexus中的<classname>LifecycleMapping</classname>组件。在你的插件项目中，在src/main/resources下创建一个<filename>META-INF/plexus/components.xml</filename>文件。在这个components.xml中添加如<xref
      linkend="ex-override-lifecycle" />的内容。在<varname>role-hint</varname>下设置打包类型的名称，在pheases中设置包含所有需要绑定目标的坐标（省略version）。多个目标可以用逗号分隔，绑定到同一个阶段。</para>

      <para><example id="ex-override-lifecycle">
          <title>覆盖默认生命周期</title>

          <programlisting language="xml">&lt;component-set&gt;
  &lt;components&gt;
    &lt;component&gt;
      &lt;role&gt;org.apache.maven.lifecycle.mapping.LifecycleMapping&lt;/role&gt;
      &lt;role-hint&gt;zip&lt;/role-hint&gt;
      &lt;implementation&gt;org.apache.maven.lifecycle.mapping.DefaultLifecycleMapping&lt;/implementation&gt;
      &lt;configuration&gt;
        &lt;phases&gt;
          &lt;process-resources&gt;org.apache.maven.plugins:maven-resources-plugin:resources&lt;/process-resources&gt;
          &lt;compile&gt;org.apache.maven.plugins:maven-compiler-plugin:compile&lt;/compile&gt;
          &lt;package&gt;org.sonatype.mavenbook.plugins:maven-zip-plugin:zip&lt;/package&gt;
        &lt;/phases&gt;
      &lt;/configuration&gt;
    &lt;/component&gt;
  &lt;/components&gt;
&lt;/component-set&gt;
</programlisting>
        </example></para>

      <para>如果你创建了一个插件，它定义了新的打包类型和定制的生命周期，Maven在将你的插件添加到项目POM中并设置extensions元素为true之前，对你插件的定义一概不知。只有在那之后，Maven才会扫描你的插件，而不仅仅只是运行Mojo，它会查找<filename>META-INF/plexus</filename>下的<filename>components.xml</filename>文件，然后它会在你的项目中使新的打包类型可用。</para>

      <para><example>
          <title>作为一个Extension配置一个插件</title>

          <programlisting language="xml">&lt;project&gt;
  ...
  &lt;build&gt;
    ...
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;com.training.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-zip-plugin&lt;/artifactId&gt;
        &lt;extensions&gt;true&lt;/extensions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</programlisting>
        </example></para>

      <para>一旦你添加了插件，并将extensions元素设置成true，你就可以使用这个定制的打包类型，你的项目就能运行关联到该打包类型的定制生命周期。</para>
    </section>
  </section>
</chapter>
