<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="simple-project">
  <title>A Simple Maven Project</title>

  <section id="simple-project-sect-intro">
    <title>Introduction</title>

    <para>In this chapter, we introduce a simple project created from scratch
    using the Maven Archetype plugin. This elementary application provides us
    with the opportunity to discuss some core Maven concepts while you follow
    along with the development of the project.</para>

    <para>Before you can start using Maven for complex, multimodule builds, we
    have to start with the basics. If you’ve used Maven before, you’ll notice
    that it does a good job of taking care of the details. Your builds tend to
    “just work,” and you only really need to dive into the details of Maven
    when you want to customize the default behavior or write a custom plugin.
    However, when you do need to dive into the details, a thorough
    understanding of the core concepts is essential. This chapter aims to
    introduce you to the simplest possible Maven project and then presents
    some of the core concepts that make Maven a solid build platform. After
    reading it, you’ll have a fundamental understanding of the build
    lifecycle, Maven repositories, dependency management, and the Project
    Object Model (<acronym>POM</acronym>).</para>

    <section id="simple-project-sect-downloading-example">
      <title>Downloading this Chapter's Example</title>

      <para>This chapter develops a very simple example which will be used to
      explore core concepts of Maven. If you follow the steps described in
      this chapter, you shouldn't need to download the examples to recreate
      the code produced by the Maven. We will be using the Maven Archetype
      plugin to create this simple project and this chapter doesn't modify the
      project in any way. If you would prefer to read this chapter with the
      final example source code, this chapter's example project may be
      downloaded with the book's example code at <ulink
      url="http://www.sonatype.com/book/mvn-examples-1.0.zip">http://www.sonatype.com/book/mvn-examples-1.0.zip</ulink>
      or <ulink
      url="http://www.sonatype.com/book/mvn-examples-1.0.tar.gz">http://www.sonatype.com/book/mvn-examples-1.0.tar.gz</ulink>.
      Unzip this archive in any directory, and then go to the
      <filename>ch03/</filename> directory. In the <filename>ch03/</filename>
      directory you will see a directory named <filename>simple/</filename>
      which contains the source code for this chapter. If you wish to follow
      along with the example code in a web browser, go to <ulink
      url="http://www.sonatype.com/book/examples-1.0">http://www.sonatype.com/book/examples-1.0</ulink>
      and click on the <filename>ch03/</filename> directory.</para>
    </section>
  </section>

  <section id="simple-project-sect-create-simple">
    <title>Creating a Simple Project</title>

    <para>To start a new Maven project, use the Maven Archetype plugin from
    the command line.</para>

    <screen><command>$ mvn archetype:create -DgroupId=org.sonatype.mavenbook.ch03 \
                                         -DartifactId=simple \
                                         -DpackageName=org.sonatype.mavenbook
</command>[INFO] Scanning for projects...
[INFO] Searching repository for plugin with prefix: 'archetype'.               
[INFO] artifact org.apache.maven.plugins:maven-archetype-plugin: checking for 
       updates from central
[INFO] -----------------------------------------------------------------------
[INFO] Building Maven Default Project
[INFO]    task-segment: [archetype:create] (aggregator-style)
[INFO] --------------------------------------------------------------------
[INFO] [archetype:create]
[INFO] artifact org.apache.maven.archetypes:maven-archetype-quickstart: \
       checking for updates from central
[INFO] Parameter: groupId, Value: org.sonatype.mavenbook.ch03
[INFO] Parameter: packageName, Value: org.sonatype.mavenbook
[INFO] Parameter: basedir, Value: /Users/tobrien/svnw/sonatype/examples
[INFO] Parameter: package, Value: org.sonatype.mavenbook
[INFO] Parameter: version, Value: 1.0-SNAPSHOT
[INFO] Parameter: artifactId, Value: simple
[INFO] * End of debug info from resources from generated POM *
[INFO] Archetype created in dir: /Users/tobrien/svnw/sonatype/examples/simple
</screen>

    <para><command>mvn</command> is the Maven 2 command.
    <varname>archetype:create</varname> is called a Maven goal. If you
    are<indexterm>
        <primary>goals</primary>

        <secondary>about</secondary>
      </indexterm><indexterm>
        <primary>Maven goals, about</primary>
      </indexterm><indexterm>
        <primary>parent POM</primary>

        <seealso>POM</seealso>
      </indexterm><indexterm>
        <primary>top-level POM</primary>

        <seealso>POM</seealso>
      </indexterm> familiar with Apache Ant, a Maven goal is analogous to an
    Ant target; both describe a unit of work to be completed in a build. The
    <varname>-Dname=value</varname> pairs are arguments that are passed to the
    goal and take the form of <varname>-D</varname> properties, similar to the
    system property options you might pass to the Java Virtual Machine via the
    command line. The purpose of the <varname>archetype:create</varname> goal
    is to quickly create a project from an archetype. In this context,
    an<indexterm>
        <primary sortas="archetypes">archetypes, defined</primary>
      </indexterm> archetype is defined as “an original model or type after
    which other similar things are patterned; a prototype.”<footnote
        id="foot-archetype-def">
        <para><emphasis>The American Heritage Dictionary of the English
        Language</emphasis>.</para>
      </footnote> A number of archetypes are available in Maven for anything
    from a simple Swing application to a complex web application. In this
    chapter, we are going to use the most basic archetype to create a simple
    skeleton starter project. The plugin is the prefix
    <literal>archetype</literal>, and the goal is
    <literal>create</literal>.</para>

    <para>Once we've generated a project, take a look at the directory
    structure Maven created under the simple directory:</para>

    <screen>simple/<co id="coDef-simple-fs-root"
        linkends="coRef-simple-fs-root" />
simple/pom.xml<co id="coDef-simple-fs-pom" linkends="coRef-simple-fs-pom" />
      /src/
      /src/main/<co id="coDef-simple-fs-main" linkends="coRef-simple-fs-main" />
          /main/java
      /src/test/<co id="coDef-simple-fs-test" linkends="coRef-simple-fs-test" />
          /test/java</screen>

    <para>This generated directory adheres to the Maven Standard
    Directory<indexterm>
        <primary>Standard Dirctory Layout</primary>
      </indexterm><indexterm>
        <primary>Maven Standard Dirctory Layout</primary>
      </indexterm> Layout. We’ll get into more details later in this chapter,
    but for now, let’s just try to understand these few basic <phrase
    role="keep-together">directories</phrase>:</para>

    <calloutlist>
      <callout arearefs="coDef-simple-fs-root" id="coRef-simple-fs-root">
        <para>The Maven Archetype plugin creates a directory that matches the
        <varname>artifactId</varname>. Simple. This is known as the project’s
        <indexterm>
            <primary>base directory</primary>
          </indexterm> base directory.</para>
      </callout>

      <callout arearefs="coDef-simple-fs-pom" id="coRef-simple-fs-pom">
        <para>Every Maven project has what is known as a Project Object Model
        (<acronym>POM</acronym>) in a file named <filename>pom.xml</filename>.
        This file describes the project, configures plugins, and declares
        dependencies.</para>
      </callout>

      <callout arearefs="coDef-simple-fs-main" id="coRef-simple-fs-main">
        <para>Our project's source code and resources are placed under
        <filename>src/main</filename>. In the case of our simple Java project
        this will consist of a few Java classes and some properties file. In
        another project, this could be the document root of a web application
        or configuration files for an application server. In a Java project,
        Java classes are placed in <filename>src/main/java</filename> and
        classpath resources are placed in
        <filename>src/main/resources</filename>.</para>
      </callout>

      <callout arearefs="coDef-simple-fs-test" id="coRef-simple-fs-test">
        <para>Our project's test cases are located in
        <filename>src/test</filename>. Under this directory, Java classes such
        as JUnit or TestNG tests are placed in
        <filename>src/test/java</filename>, and classpath resources for tests
        are located in <filename>src/test/resources</filename>.</para>
      </callout>
    </calloutlist>

    <para>The Maven Archetype plugin generated a single class
    <classname>org.sonatype.mavenbook.App</classname>, which is a 13-line Java
    class with a static main function that prints out a message:</para>

    <programlisting language="java">package org.sonatype.mavenbook;

/**
 * Hello world!
 *
 */
public class App 
{
    public static void main( String[] args )
    {
        System.out.println( "Hello World!" );
    }
}
</programlisting>

    <para>The simplest Maven archetype generates the simplest possible
    program: a program which prints "Hello World!" to standard output.</para>
  </section>

  <section id="simple-project-sect-building-simple">
    <title>Building a Simple Project</title>

    <para>Once you have created the project with the Maven Archetype plugin by
    following the directions from the previous section (<xref
    linkend="simple-project-sect-create-simple" />) you will want to build and
    package the application. To do so, run <command>mvn install</command> from
    the<indexterm>
        <primary>mvn install command</primary>
      </indexterm><indexterm>
        <primary>building applications</primary>
      </indexterm><indexterm>
        <primary>packaging applications</primary>
      </indexterm><indexterm>
        <primary>applications, building and packaging</primary>
      </indexterm> directory that contains the
    <filename>pom.xml</filename>:</para>

    <screen><command>$ mvn install
</command>[INFO] Scanning for projects...
[INFO] ----------------------------------------------------------------------
[INFO] Building simple
[INFO]    task-segment: [install]
[INFO] ----------------------------------------------------------------------
[INFO] [resources:resources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:compile]
[INFO] Compiling 1 source file to /simple/target/classes
[INFO] [resources:testResources]
[INFO] Using default encoding to copy filtered resources.
[INFO] [compiler:testCompile]
[INFO] Compiling 1 source file to /simple/target/test-classes
[INFO] [surefire:test]
[INFO] Surefire report directory: /simple/target/surefire-reports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------
Running org.sonatype.mavenbook.AppTest
Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.105 sec

Results :

Tests run: 1, Failures: 0, Errors: 0, Skipped: 0

[INFO] [jar:jar]
[INFO] Building jar: /simple/target/simple-1.0-SNAPSHOT.jar
[INFO] [install:install]
[INFO] Installing /simple/target/simple-1.0-SNAPSHOT.jar to \
  ~/.m2/repository/com/sonatype/maven/ch03/simple/1.0-SNAPSHOT/ \
  simple-1.0-SNAPSHOT.jar
</screen>

    <para>You've just created, compiled, tested, packaged, and installed the
    simplest possible Maven project. To prove to yourself that this program
    works, run it from the command line.</para>

    <screen><command>$ java -cp target/simple-1.0-SNAPSHOT.jar org.sonatype.mavenbook.App
</command>Hello World!
</screen>
  </section>

  <section id="simple-project-sect-pom">
    <title>Simple Project Object Model</title>

    <para>When Maven executes, it looks to the Project Object Model
    for<indexterm>
        <primary>POM (Project Object Model)</primary>
      </indexterm><indexterm>
        <primary>Project Object Model</primary>

        <see>POM; pom.xml file</see>
      </indexterm><indexterm>
        <primary>pom.xml file</primary>
      </indexterm> information about the project. The <acronym>POM</acronym>
    answers such questions as: What type of project is this? What is the
    project’s name? Are there any build customizations for this project? <xref
    linkend="example_simple-project-pom" /> shows the default
    <filename>pom.xml</filename> file created by the Maven Archetype plugin’s
    create goal.</para>

    <example id="example_simple-project-pom">
      <title>Simple project's <filename>pom.xml</filename> file</title>

      <programlisting language="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" 
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
                      http://maven.apache.org/maven-v4_0_0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.sonatype.mavenbook.ch03&lt;/groupId&gt;
  &lt;artifactId&gt;simple&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;name&gt;simple&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</programlisting>
    </example>

    <para>This <filename>pom.xml</filename> file is the most basic
    <acronym>POM</acronym> you will ever deal with for a Maven project,
    usually a <acronym>POM</acronym> file is considerably more complex:
    defining multiple dependencies and customizing plugin behavior. The first
    few elements—<sgmltag>groupId</sgmltag>, <sgmltag>artifactId</sgmltag>,
    <sgmltag>packaging</sgmltag>, <sgmltag>version</sgmltag>—are what is known
    as the Maven coordinates which uniquely identify a project.
    <sgmltag>name</sgmltag> and <sgmltag>url</sgmltag> are descriptive
    elements of the <acronym>POM</acronym> providing a human readable name and
    associating the project with a web site. The
    <sgmltag>dependencies</sgmltag> element defines a single, test-scoped
    dependency on a unit testing framework called JUnit. These topics will be
    further introduced in <xref linkend="simple-project-sect-simple-core" />,
    all you need to know, at this point, is that the
    <filename>pom.xml</filename> is the file that makes Maven go.</para>

    <para>Maven always executes against an effective <acronym>POM</acronym>, a
    combination of settings from this project's <filename>pom.xml</filename>,
    all parent <acronym>POM</acronym>s, a super-<acronym>POM</acronym> defined
    within Maven, user-defined settings, and active profiles. All projects
    ultimately extend the super-<acronym>POM</acronym>, which defines a set of
    sensible default configuration settings and which is fully explained in
    <xref linkend="pom-relationships" />. While your project might have a
    relatively minimal <filename>pom.xml</filename>, the contents of your
    project's <acronym>POM</acronym> are interpolated with the contents of all
    parent <acronym>POM</acronym>s, user settings, and any active profiles. To
    see this "effective" <acronym>POM</acronym>, run the following command in
    the simple project's base directory.</para>

    <screen>$ <command>mvn help:effective-pom</command></screen>

    <para>When you run this, you should see a much larger
    <acronym>POM</acronym> which exposes the default settings of Maven. This
    goal can come in handy if you are trying to debug a build and want to see
    how all of the current project's ancestor POMs are contributing to the
    effective POM. For more information about the Maven Help plugin, see <xref
    linkend="installation-sect-help-plugin-install" />.</para>
  </section>

  <section id="simple-project-sect-simple-core">
    <title>Core Concepts</title>

    <para>Having just run Maven for the first time, it is a good time to
    introduce a few of the core concepts of Maven. In the previous example,
    you generated a project which consisted of a <acronym>POM</acronym> and
    some code assembled in the Maven standard directory layout. You then
    execute Maven with a lifecycle phase as an argument which prompted Maven
    to execute a series of Maven plugin goals. Lastly, you installed a Maven
    artifact into your local repository. Wait? What is a "lifecycle"? What is
    a "local repository"? The following section defines some of Maven's
    central concepts.</para>

    <section id="simple-project-sect-plugins-goals">
      <title>Maven Plugins and Goals</title>

      <para>In the previous section, we ran Maven with two different types
      of<indexterm>
          <primary>Maven plugins</primary>

          <see>plugins</see>
        </indexterm><indexterm>
          <primary>goals</primary>

          <seealso>plugins</seealso>
        </indexterm> command-line <phrase
      role="keep-together">arguments</phrase>. The first command was a single
      plugin goal, the <varname>create</varname> goal of the Archetype plugin.
      The second execution of Maven was a lifecycle phase,
      <varname>install</varname>. To<indexterm>
          <primary>executing goals</primary>
        </indexterm><indexterm>
          <primary>executing goals</primary>

          <seealso>goals</seealso>
        </indexterm> execute a single Maven plugin goal, we used the syntax
      <command>mvn archetype:create</command>, where
      <varname>archetype</varname> is the identifier of a plugin and
      <varname>create</varname> is the identifier of a goal. When Maven
      executes a plugin goal, it prints out the plugin identifier and goal
      identifier to standard output:</para>

      <screen><command>$ mvn archetype:create -DgroupId=org.sonatype.mavenbook.ch03 \
                                        -DartifactId=simple \
                                        -DpackageName=org.sonatype.mavenbook
</command>...
<emphasis>[INFO] [archetype:create]</emphasis>
[INFO] artifact org.apache.maven.archetypes:maven-archetype-quickstart: \
       checking for updates from central
...
</screen>

      <para>A Maven Plugin is a collection of one or more goals. Examples of
      Maven plugins can be simple core plugins like the Jar plugin which
      contains goals for creating <acronym>JAR</acronym> files, Compiler
      plugin which contains goals for compiling source code and unit tests, or
      the Surefire plugin which contains goals for executing unit tests and
      generating reports. Other, more specialized Maven plugins include
      plugins like the Hibernate3 plugin for integration with the popular
      persistence library Hibernate, the JRuby plugin which allows you to
      execute ruby as part of a Maven build or to write Maven plugins in Ruby.
      Maven also provides for the ability to define custom plugins. A custom
      plugin can be written in Java, or a plugin can be written in any number
      of languages including Ant, Groovy, beanshell, and, as previously
      mentioned, Ruby.</para>

      <figure>
        <title>A Plugin Contains Goals</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figs/web/simple-project_plugin.png"
                       width="5in" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>A goal is a specific task that may be executed as a
      standalone<indexterm>
          <primary>goals</primary>

          <secondary>defined</secondary>
        </indexterm> goal or along with other goals as part of a larger build.
      A goal is a “unit of work” in Maven. Examples of goals include the
      <varname>compile</varname> goal in the Compiler plugin, which compiles
      all of the source code for a project, or the <varname>test</varname>
      goal of the Surefire plugin, which can execute unit tests. Goals are
      configured via configuration properties that can be used to customize
      behavior. For example, the <varname>compile</varname> goal of the
      Compiler plugin defines a set of configuration <phrase
      role="keep-together">parameters</phrase> that allow you to specify the
      target JDK version or whether to use the compiler optimizations. In the
      previous example, we passed in the configuration parameters
      <varname>groupId</varname> and <varname>artifactId</varname> to the
      <varname>create</varname> goal of the Archetype plugin via the
      command-line parameters
      <command>-DgroupId=org.sonatype.mavenbook.ch03</command> and
      <command>-DartifactId=simple</command>. We <phrase
      role="keep-together">also</phrase> passed the
      <varname>packageName</varname> parameter to the
      <literal>create</literal> goal as
      <package>org.sonatype.mavenbook</package>. If we had omitted the
      <varname>packageName</varname> parameter, the package name would have
      defaulted to <package>org.sonatype.mavenbook.ch03</package>.</para>

      <para><note>
          <para>When referring to a plugin goal, we frequently use the
          shorthand notation:
          <replaceable>pluginId</replaceable><literal>:</literal><replaceable>goalId</replaceable>.
          For example, when referring to the <literal>create</literal> goal in
          the Archetype plugin, we write
          <varname>archetype:create</varname>.</para>
        </note></para>

      <para>Goals define parameters that can define sensible default values.
      In the <varname>archetype:</varname><varname>create</varname> example,
      we did not specify what kind of archetype the goal was to create on our
      command line; we simply passed in a <varname>groupId</varname> and an
      <varname>artifactId</varname>. This is our first brush with<indexterm>
          <primary>convention over configuration</primary>
        </indexterm> <emphasis>convention over configuration</emphasis>. The
      convention, or default, for the <varname>create</varname> goal is to
      create a simple project called Quickstart. The <varname>create</varname>
      goal defines a configuration property
      <varname>archetypeArtifactId</varname> that has a default value of
      <varname>maven-archetype-</varname><varname>quickstart</varname>. The
      Quickstart archetype generates a minimal project shell that contains a
      <acronym>POM</acronym> and a single class. The Archetype plugin is far
      more powerful than this first example suggests, but it is a great way to
      get new projects started fast. Later in this book, we’ll show you how
      the Archetype plugin can be used to generate more complex projects such
      as web applications, and how you can use the Archetype plugin to define
      your own set of projects.</para>

      <para>The core of Maven has little to do with the specific tasks
      involved in your project’s build. By itself, Maven doesn’t know how to
      compile your code or even how to make a <acronym>JAR</acronym> file. It
      delegates all of this work to Maven plugins like the Compiler plugin and
      the Jar plugin, which are downloaded on an as-needed basis and
      periodically updated from the central Maven repository. When you
      download Maven, you are getting the core of Maven, which consists of a
      very basic shell that knows only how to parse the command line, manage a
      classpath, parse a <acronym>POM</acronym> file, and download Maven
      plugins as needed. By keeping the Compiler plugin separate from Maven’s
      core and providing for an update mechanism, Maven makes it easier for
      users to have access to the latest options in the compiler. In this way,
      Maven plugins allow for universal reusability of common build logic. You
      are not defining the compile task in a build file; you are using a
      Compiler plugin that is shared by every user of Maven. If there is an
      improvement to the Compiler plugin, every project that uses Maven can
      immediately benefit from this change. (And, if you don’t like the
      Compiler plugin, you can override it with your own
      implementation.)</para>
    </section>

    <section id="simple-project-sect-lifecycle">
      <title>Maven Lifecycle</title>

      <para>The second command we ran in the previous section<indexterm>
          <primary>Maven lifecycle</primary>

          <see>build lifecycle</see>
        </indexterm><indexterm>
          <primary>lifecycle, Maven</primary>

          <see>build lifecycle</see>
        </indexterm><indexterm class="startofrange" id="buildlife">
          <primary>build lifecycle</primary>
        </indexterm><indexterm>
          <primary>phases, lifecycle</primary>

          <see>build lifecycle</see>
        </indexterm> was <command>mvn install</command>. This command didn’t
      specify a plugin goal; instead, it specified a Maven lifecycle phase. A
      phase is a step in what Maven calls the “build lifecycle.” The build
      lifecycle is an ordered sequence of phases involved in building a
      project. Maven can support a number of different lifecycles, but the one
      that’s most often used is the default<indexterm>
          <primary>default Maven lifecycle</primary>
        </indexterm><indexterm>
          <primary>build lifecycle</primary>

          <secondary>default Maven lifecycle</secondary>
        </indexterm> Maven lifecycle, which begins with a phase to validate
      the basic integrity of the project and ends with a phase that involves
      deploying a project to production. Lifecycle phases are intentionally
      vague, defined solely as validation, testing, or deployment, and they
      may mean different things to different projects. For example, the
      <varname>package</varname> phase in a project that produces a
      <acronym>JAR</acronym>, means “package this project into a JAR”; in a
      project that produces a web application, the <varname>package</varname>
      phase may produce a <acronym>WAR</acronym> file.</para>

      <para>Plugin goals can be attached<indexterm>
          <primary>plugin goals</primary>

          <see>goals</see>
        </indexterm><indexterm>
          <primary>goals</primary>

          <secondary>attaching to lifecycle phases</secondary>
        </indexterm> to a lifecycle phase. As Maven moves through the phases
      in a lifecycle, it will execute the goals attached to each particular
      phase. Each phase may have zero or more goals bound to it. In the
      previous section, when you ran <command>mvn install</command>, you might
      have noticed that more than one goal was executed. Examine the output
      after running <command>mvn install</command> and take note of the
      various goals that are executed. When this simple example reached the
      <varname>package</varname> phase, it executed the <varname>jar</varname>
      goal in the Jar plugin. Since our simple Quickstart project has (by
      default) a <varname>jar</varname> packaging type, the
      <varname>jar:jar</varname> goal is bound to the
      <varname>package</varname> phase.</para>

      <para><figure>
          <title>A Goal Binds to a Phase</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/web/simple-project_phasebinding.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>We know that the <varname>package</varname> phase is going to
      create a <acronym>JAR</acronym> file for a project with
      <varname>jar</varname> packaging. But what of the goals preceding it,
      such as <varname>compiler:compile</varname> and <varname
      role="keep-together">surefire:test</varname>? These goals are executed
      as Maven steps through the phases preceding <varname>package</varname>
      in the<indexterm>
          <primary>executing lifecycle phases</primary>
        </indexterm> Maven lifecycle; executing a phase will first execute all
      preceding phases in order, ending with the phase specified on the
      command line. Each phase corresponds to zero or more goals, and since we
      haven’t performed any plugin configuration or customization, this
      example binds a set of standard plugin goals to the default lifecycle.
      The following goals are executed in order when Maven walks through the
      default lifecycle ending with <varname>package</varname>:</para>

      <variablelist>
        <varlistentry>
          <term><varname>resources:resources</varname></term>

          <listitem>
            <para>The <varname>resources</varname> goal of the
            Resources<indexterm>
                <primary>Resources plugin</primary>

                <secondary>resources goal</secondary>
              </indexterm> plugin is bound to the
            <varname>process-resources</varname> phase. This goal copies all
            of the resources from <filename>src/main/resources</filename> and
            any other configured resource directories to the output
            directory.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>compiler:compile</varname></term>

          <listitem>
            <para>The <varname>compile</varname> goal of the Compiler
            plugin<indexterm>
                <primary>compile:compile goal</primary>
              </indexterm><indexterm>
                <primary>Compiler plugin</primary>

                <secondary>compile goal</secondary>
              </indexterm> is bound to the <varname>compile</varname> phase.
            This goal compiles all of the source code from
            <filename>src/main/java</filename> or any other configured source
            directories to the output directory.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>resources:testResources</varname></term>

          <listitem>
            <para>The <varname>testResources</varname> goal of the
            Resources<indexterm>
                <primary>Resources plugin</primary>

                <secondary>testResources goal</secondary>
              </indexterm> plugin is bound to the
            <varname>process-test-resources</varname> phase. This goal copies
            all of the resources from <filename>src/test/resources</filename>
            and any other configured test resource directories to a test
            output directory.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>compiler:testCompile</varname></term>

          <listitem>
            <para>The <varname>testCompile</varname> goal of the
            Compiler<indexterm>
                <primary>Compiler plugin</primary>

                <secondary>testCompile goal</secondary>
              </indexterm> plugin is bound to the
            <varname>test-compile</varname> phase. This goal compiles test
            cases from <filename>src/test/java</filename> and any other
            configured test source directories to a test output
            directory.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>surefire:test</varname></term>

          <listitem>
            <para>The <varname>test</varname> goal of the Surefire plugin
            is<indexterm>
                <primary>Surefire plugin</primary>

                <secondary>test goal</secondary>
              </indexterm><indexterm>
                <primary>Maven Surefire plugin</primary>

                <secondary>test goal</secondary>
              </indexterm><indexterm>
                <primary>testing</primary>

                <secondary>Surefire:test goal</secondary>
              </indexterm> bound to the <varname>test</varname> phase. This
            goal executes all of the tests and creates output files that
            capture detailed results. By default, this goal will terminate a
            build if there is a test failure.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>jar:jar</varname></term>

          <listitem>
            <para>The <varname>jar</varname> goal of the Jar plugin is
            bound<indexterm>
                <primary>jar:jar goal</primary>
              </indexterm> to the <varname>package</varname> phase. This goal
            packages the output directory into a JAR file.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para><figure>
          <title>Bound Goals are Run when Their Phases Execute</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/web/simple-project_lifecyclebinding.png" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>To summarize, when we executed <command>mvn install</command>,
      Maven executes all phases up to the install phase, and in the process of
      stepping through the life cycle phases it executes all goals bound to
      each phase. Instead of executing a Maven lifecycle goal you could
      achieve the same results by specifying a sequence of plugin goals as
      follows:</para>

      <screen><command>mvn resources:resources \
    compiler:compile \
    resources:testResources \
    compiler:testCompile \
    surefire:test \
    jar:jar \
    install:install</command> 
</screen>

      <para>It is much easier to execute lifecycle phases that it is to
      specify explicit goals on the command line, and the common lifecycle
      allows every project that uses Maven to adhere to a well-defined set of
      standards. The lifecycle is what allows a developer to jump from one
      Maven project to another without having to know very much about the
      details of each particular project's build. If you can build one Maven
      project, you can build them all.</para>
    </section>

    <section id="simple-project-sect-maven-coordinates">
      <title>Maven Coordinates</title>

      <para>The Archetype plugin created a project with a file named<indexterm
          class="startofrange" id="coord1">
          <primary>Maven coordinates</primary>
        </indexterm><indexterm class="startofrange" id="coord2">
          <primary>coordinates</primary>
        </indexterm> <filename>pom.xml</filename>. This is the Project Object
      Model (<acronym>POM</acronym>), a declarative description of a project.
      When Maven executes a goal, each goal has access to the information
      defined in a project’s <acronym>POM</acronym>. When the
      <varname>jar:jar</varname> goal needs to create a <acronym>JAR</acronym>
      file, it looks to the <acronym>POM</acronym> to find out what the JAR
      file’s name is. When the <varname>compiler:compile</varname> task
      compiles Java source code into bytecode, it looks to the
      <acronym>POM</acronym> to see if there are any parameters for the
      compile goal. Goals execute in the context of a <acronym>POM</acronym>.
      Goals are actions we wish to take upon a project, and a project is
      defined by a <acronym>POM</acronym>. The <acronym>POM</acronym> names
      the project, provides a set of unique identifiers (coordinates) for a
      project, and defines the relationships between this project and others
      through dependencies, parents, and prerequisites. A
      <acronym>POM</acronym> can also customize plugin behavior and supply
      information about the community and developers involved in a
      project.</para>

      <para>Maven Coordinates define a set of identifiers which can be used to
      uniquely identify a project, a dependency, or a plugin in a Maven
      <acronym>POM</acronym>. Take a look at the following
      <acronym>POM</acronym>.</para>

      <para><figure>
          <title>A Maven Project's Coordinates</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/web/simple-project_annopom.png"
                         width="6in" />
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>We've highlighted the Maven coordinates for this project: the
      <varname>groupId</varname>, <varname>artifactId</varname>,
      <varname>version</varname> and <varname>packaging</varname>. These
      combined identifiers make up a project's coordinates.<footnote
          id="foot-simple-classify">
          <para>There is a fifth, seldom-used coordinate named
          <varname>classifier</varname> which we will introduce later in the
          book. You can feel free to ignore classifiers for now.</para>
        </footnote>Just like in any other coordinate system, a Maven
      coordinate is an address for a specific point in "space": from general
      to specific. Maven pinpoints a project via its coordinates when one
      project relates to another, either as a dependency, a plugin, or a
      parent project reference. Maven coordinates are often written using a
      colon as a delimiter in the following format:
      <code>groupId:artifactId:packaging:version</code>. In the above
      <filename>pom.xml</filename> file for our current project, its
      coordinate is represented as
      <code>mavenbook:my-app:jar:1.0-SNAPSHOT</code>. This notation also
      applies to project dependencies, our project relies on JUnit version
      3.8.1, it contains a dependency on
      <varname>junit:junit:jar:3.8.1</varname>.</para>

      <variablelist>
        <varlistentry>
          <term><varname>groupId</varname></term>

          <listitem>
            <para>The group, company, team, organization, project, or
            other<indexterm>
                <primary>groupId attribute (pom.xml)</primary>
              </indexterm> group. The convention for group identifiers is that
            they begin with the reverse domain name of the organization that
            creates the project. Projects from Sonatype would have a
            <varname>groupId</varname> that begins with
            <package>com.sonatype</package>, and projects in the Apache
            Software Foundation would have a <varname>groupId</varname> that
            starts with <package>org.apache</package>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>artifactId</varname></term>

          <listitem>
            <para>A unique identifier under <varname>groupId</varname>
            that<indexterm>
                <primary>artifactId attribute (pom.xml)</primary>
              </indexterm> represents a single project.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><varname>version</varname></term>

          <listitem>
            <para>A specific release of a project. Projects that have
            been<indexterm>
                <primary>version attribute (pom.xml)</primary>
              </indexterm> released have a fixed version identifier that
            refers to a specific version of the project. Projects undergoing
            active development can use a special identifier that marks a
            version as a <varname>SNAPSHOT</varname>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>The packaging format of a project is also an important component
      in the Maven coordinates, but it isn't a part of a project's unique
      identifier. A project's <varname>groupId:artifactId:version</varname>
      make that project unique; you can't have a project with the same three
      <varname>groupId</varname>, <varname>artifactId</varname>, and
      <varname>version</varname> identifiers.</para>

      <variablelist>
        <varlistentry>
          <term><varname>packaging</varname></term>

          <listitem>
            <para>The type of project, defaulting to
            <varname>jar</varname>,<indexterm>
                <primary>packaging attribute (pom.xml)</primary>
              </indexterm> describing the packaged output produced by a
            project. A project with packaging <varname>jar</varname> produces
            a <acronym>JAR</acronym> archive; a project with packaging
            <varname>war</varname> produces a web application.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para>These four elements become the key to locating and using one
      particular project in the vast space of other “Mavenized” projects .
      Maven repositories (public,<indexterm>
          <primary>repositories</primary>
        </indexterm><indexterm>
          <primary>Maven repositories</primary>
        </indexterm> private, and local) are organized according to these
      identifiers. When this project is installed into the local Maven
      repository, it immediately becomes locally available to any other
      project that wishes to use it. All you must do is add it as a dependency
      of another project <indexterm class="endofrange"
      startref="coord1"></indexterm><indexterm class="endofrange"
      startref="coord2"></indexterm>using the unique Maven coordinates for a
      specific artifact.</para>

      <para><figure>
          <title>Maven Space is a coordinate system of projects</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="figs/web/simple-project_mavenspace.png"
                         width="6in" />
            </imageobject>
          </mediaobject>
        </figure></para>
    </section>

    <section id="simple-project-section-simple-repo">
      <title>Maven Repositories</title>

      <para>When you run Maven for the first time, you will notice that Maven
      downloads a number of files from a remote Maven repository. If the
      simple project was the first time you ran Maven, the first thing it will
      do is download the latest release of the Resources plugin when it
      triggers the <varname>resources:resource</varname> goal. In Maven,
      artifacts and plugins are retrieved from a remote repository when they
      are needed. One of the reasons the initial Maven download is so small
      (1.5 MiB) is due to the fact that Maven doesn't ship with much in the
      way of plugins. Maven ships with the bare minimum and fetches from a
      remote repository when it needs to. Maven ships with a default remote
      repository location (<ulink
      url="http://repo1.maven.org/maven2">http://repo1.maven.org/maven2</ulink>)
      which it uses to download the core Maven plugins and
      dependencies.</para>

      <para>Often you will be writing a project which depends on libraries
      that are neither free nor publicly distributed. In this case you will
      need to either setup a custom repository inside your organization's
      network or download and install the dependencies manually. The default
      remote repositories can be replaced or augmented with references to
      custom Maven repositories maintained by your organization. There are
      multiple products available to allow organizations to manage and
      maintain mirrors of the public Maven repositories.</para>

      <para>What makes a Maven repository a Maven repository? The Maven
      repository is defined by structure, a repository is a collection of
      project artifacts stored in a structure and format which can be easily
      understood by Maven. In a Maven repository everything is stored in a
      directory structure that closely matches a project's Maven coordinates.
      You can see this structure by opening up a web browser and browsing the
      central Maven repository at <ulink
      url="http://repo1.maven.org/maven2/">http://repo1.maven.org/maven2/</ulink>.
      You will see that an artifact with the coordinates
      <varname>org.apache.commons:commons-email:1.1</varname> is available
      under the directory
      <filename>/org/apache/commons/commons-email/1.1/</filename> in a file
      named <filename>commons-email-1.1.jar</filename>. The standard for a
      Maven repository is to store an artifact in the following directory
      relative to the root of the repository: <screen>/&lt;<varname>groupId</varname>&gt;/&lt;<varname>artifactId</varname>&gt;/&lt;<varname>version</varname>&gt;/&lt;<varname>artifactId</varname>&gt;-&lt;version&gt;.&lt;<varname>packaging</varname>&gt;</screen></para>

      <para>Maven downloads artifacts and plugins from a remote repository to
      your local machine and stores these artifacts in your local Maven
      repository. Once Maven has downloaded an artifact from the remote Maven
      repository it never needs to download that artifact again as Maven will
      always look for the artifact in the local repository before looking
      elsewhere. On Windows XP, your local repository is likely in
      <filename>C:\Documents and Settings\USERNAME\.m2\repository</filename>,
      and on Windows Vista, your local repository is in
      <filename>C:\Users\USERNAME\.m2\repository</filename>. On Unix systems,
      your local Maven repository is available in
      <filename>~/.m2/repository</filename>. When you build a project like the
      simple project you created in the previous section, the
      <varname>install</varname> phase executes a goal which installs your
      project's artifacts in your local Maven repository.</para>

      <para>In your local repository, you should be able to see the artifact
      created by our simple project. If you run the <command>mvn
      install</command> command, Maven will install our project's artifact in
      your local repository. Try it.</para>

      <screen>$ <command>mvn install</command>
...
[INFO] [install:install]
[INFO] Installing .../simple-1.0-SNAPSHOT.jar to \
       ~/.m2/repository/com/sonatype/maven/simple/1.0-SNAPSHOT/ \
       simple-1.0-SNAPSHOT.jar
...</screen>

      <para>As you can see from the output of this command, Maven installed
      our project's <acronym>JAR</acronym> file into our local Maven
      repository. Maven uses the local repository to share dependencies across
      local projects. If you develop two projects—project A and project B—with
      project B depending on the artifact produced by project A. Maven will
      retrieve project A's artifact from your local repository when it is
      building project B. Maven repositories are both a local cache of
      artifacts downloaded from a remote repository and a mechanism for
      allowing your projects to depend on each other.</para>
    </section>

    <section id="simple-project-sect-dep-management">
      <title>Maven's Dependency Management</title>

      <para>In this chapter's simple example, Maven resolved the coordinates
      of the JUnit dependency—<varname>junit:junit:3.8.1</varname>—to a path
      in a Maven repository
      <filename>/junit/junit/3.8.1/junit-3.8.1.jar</filename>. The ability to
      locate an artifact in a repository based on Maven coordinates gives us
      the ability to define dependencies in a project's
      <acronym>POM</acronym>. If you examine the simple project's
      <filename>pom.xml</filename> file, you will see that there is a section
      which deals with <sgmltag>dependencies</sgmltag>, and that this section
      contains a single dependency—JUnit.</para>

      <para>A more complex project would contain more than one dependency, or
      it might contain dependencies that depend on other artifacts.
      Support<indexterm>
          <primary>transitive dependencies</primary>

          <secondary>support for</secondary>
        </indexterm> for transitive dependencies is one of Maven’s most
      powerful features. Let’s say your project depends on a library that, in
      turn, depends on 5 or 10 other libraries (Spring or Hibernate, for
      example). Instead of having to track down all of these dependencies and
      list them in your <filename>pom.xml</filename> explicitly, you can
      simply depend on the library you are interested in and Maven will add
      the dependencies of this library to your project’s dependencies
      implicitly. Maven will also take care of working out conflicts between
      dependencies, and provides you with the ability to customize the default
      behavior and exclude certain transitive dependencies.</para>

      <para>Let's take a look at a dependency which was downloaded to your
      local repository when you ran the previous example. Look in your local
      repository path under
      <filename>~/.m2/repository/junit/junit/3.8.1/</filename>. If you have
      been following this chapter's examples, there will be a file named
      <filename>junit-3.8.1.jar</filename> and a
      <filename>junit-3.8.1.pom</filename> file in addition to a few checksum
      files which Maven uses to verify the authenticity of a downloaded
      artifact. Note that Maven doesn't just download the JUnit<acronym>
      JAR</acronym> file, Maven also downloads a <acronym>POM</acronym> file
      for the JUnit dependency. The fact that Maven downloads
      <acronym>POM</acronym> files in addition to artifacts is central to
      Maven's support for transitive dependencies.</para>

      <para>When you install your project’s artifact in the local repository,
      you will also notice that Maven publishes a slightly modified version of
      the project’s <filename>pom.xml</filename> file in the same directory as
      the <acronym>JAR</acronym> file. Storing a <acronym>POM</acronym> file
      in the repository gives other projects information about this project,
      most importantly what dependencies it has. If Project B depends on
      Project A, it also depends on Project A’s dependencies. When Maven
      resolves a dependency artifact from a set of Maven coordinates, it also
      retrieves the <acronym>POM</acronym> and consults the dependencies
      <acronym>POM</acronym> to find any transitive dependences. These
      transitive dependencies are then added as dependencies of the current
      project.</para>

      <para>A dependency in Maven isn’t just a <acronym>JAR</acronym> file;
      it’s a <acronym>POM</acronym> file that, in turn, may declare
      dependencies on other artifacts. These dependencies of dependencies are
      called transitive dependencies, and they are made possible by the fact
      that the Maven repository stores more than just bytecode; it stores
      metadata about artifacts.</para>

      <figure>
        <title>Maven Resolves Transitive Dependencies</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figs/web/simple-project_depgraph.png"
                       width="6in" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>In the previous figure, project A depends on projects B and C.
      Project B depends on project D, and project C depends on project E. The
      full set of direct and transitive dependencies for project A would be
      projects B, C, D, and E, but all project A had to do was define a
      dependency on B and C. Transitive dependencies can come in handy when
      your project relies on other projects with several small dependencies
      (like Hibernate, Apache Struts, or the Spring Framework). Maven also
      provides you with the ability to exclude transitive dependencies from
      being included in a project's classpath.</para>

      <para>Maven also provides for different dependency scopes. The
      simple<indexterm>
          <primary>scope, dependency</primary>
        </indexterm> project’s <filename>pom.xml</filename> contains a single
      dependency—<varname>junit:junit:jar:3.8.1</varname>—with a scope of
      <varname>test</varname>. When a dependency has a scope of
      <varname>test</varname>, it will not be available to the
      <varname>compile</varname> goal of the Compiler plugin. It will be added
      to the classpath for only the <varname>compiler:testCompile</varname>
      and <varname>surefire:test</varname> goals.</para>

      <para>When you create a <acronym>JAR</acronym> for a project,
      dependencies are not bundled with the generated artifact; they are used
      only for compilation. When you use Maven to create a
      <acronym>WAR</acronym> or an <acronym>EAR</acronym> file, you can
      configure Maven to bundle dependencies with the generated artifact, and
      you can also configure it to exclude certain dependencies from the
      <acronym>WAR</acronym> file using the <varname>provided</varname> scope.
      The <varname>provided</varname> scope tells Maven that a dependency is
      needed for compilation, but should not be bundled with the output of a
      build. This scope comes in handy when you are developing a web
      application. You’ll need to compile your code against the Servlet
      specification, but you don’t want to include the Servlet
      <acronym>API</acronym> <acronym>JAR</acronym> in your web application’s
      <filename>WEB-INF/lib</filename> directory.</para>
    </section>

    <section id="simple-project-sect-site-generation">
      <title>Site Generation and Reporting</title>

      <para>Another important feature of Maven is its ability to
      generate<indexterm>
          <primary>documentation generation</primary>
        </indexterm><indexterm>
          <primary>site generation</primary>
        </indexterm><indexterm>
          <primary>report generation</primary>
        </indexterm><indexterm>
          <primary>site lifecycle phase</primary>
        </indexterm> documentation and reports. In your simple project’s
      directory, execute the following command:</para>

      <screen>$ <command>mvn site</command>
</screen>

      <para>This will execute the <varname>site</varname> lifecycle phase.
      Unlike the default build lifecycle that manages generation of code,
      manipulation of resources, compilation, packaging, etc., this lifecycle
      is concerned solely with processing site content under the
      <filename>src/site</filename> directories and generating reports. After
      this command executes, you should see a project web site in the
      <filename>target/site</filename> directory. Load
      <filename>target/site/index.html</filename> and you should see a basic
      shell of a project site. This shell contains some reports under “Project
      Reports” in the lefthand navigation menu, and it also contains
      information about the project, the dependencies, and developers
      associated with it under “Project Information.” The simple project’s web
      site is mostly empty, since the <acronym>POM</acronym> contains very
      little information about itself beyond a coordinate, a name, a
      <acronym>URL</acronym>, and a single test dependency.</para>

      <para>On this site, you’ll notice that some default reports are
      available. A unit test report communicates the success and failure of
      all unit tests in the project. Another report generates Javadoc for the
      project’s <acronym>API</acronym>. Maven provides a full range of
      configurable reports, such as the Clover report that examines unit test
      coverage, the <acronym>JXR</acronym> report that generates
      cross-referenced <acronym>HTML</acronym> source code listings useful for
      code reviews, the <acronym>PMD</acronym> report that analyzes source
      code for various coding problems, and the JDepend report that analyzes
      the dependencies between packages in a codebase. You can customize site
      reports by configuring which reports are included in a build via the
      <filename>pom.xml</filename> file.</para>
    </section>
  </section>

  <section id="simple-project-sect-summary">
    <title>Summary</title>

    <para>In this chapter, we have created a simple project, packaged the
    project into a JAR file, installed that JAR into the Maven repository for
    use by other projects, and generated a site with documentation. We
    accomplished this without writing a single line of code or touching a
    single configuration file. We also took some time to develop definitions
    for some of the core concepts of Maven. In the next chapter, we’ll start
    customizing and modifying our project <filename>pom.xml</filename> file to
    add dependencies and configure unit tests.</para>
  </section>
</chapter>